/***********************************************************************/
/*                                                                     */
/*  FILE        :iolib_inv.c                                           */
/*  DATE        :Thu, Aug 23, 2012                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :RX62T                                                 */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.53).    */
/*  NOTE:THIS IS A TYPICAL EXAMPLE.                                    */
/*                                                                     */
/***********************************************************************/
                  
#include "iodefine.h"
//#include "iodefine_RPDL.h"
#include <machine.h>
#include "iolib.h"
//#include "R_PG_default.h"
#include "define.h"
#include "testt.h"


static int  _inv_peak     = 2300;
static int  _inv_hpeak    = 2200; //1100;
static int  _inv_deadtime = 50;

int	itemp_u = 0;
int	itemp_v = 0;
int	itemp_w = 0;

int TMP_T = 0;
int TMP_P = 0;
int TMP_HP = 0;
int TMP_DEAD = 0;
unsigned char TMP_I = 0;

void  inverter_init(int fs, int dt)		// fs : 周期〈ns〉、dt：デッドタイム（ns）
{
    int		i_period;
    int		_inv_hcc;			
    
   // i_period = cIMCLK_FRQ * fs / 1000;		// 4800
     i_period = (int)((48000000.0f)/fs-1);
   // _inv_deadtime = (int)(cIMCLK_FRQ*((float)dt/1000.0));	//cIMCLK_FRQ=96(MHz)
    _inv_deadtime =50;
    _inv_hcc = i_period >> 1;			// 2400
   //_inv_peak   = i_period - _inv_deadtime - _inv_deadtime; // こちらが正しい
    _inv_peak   = i_period - _inv_deadtime;	// バグ
    _inv_hpeak  = _inv_peak>>1;
    
    TMP_T = i_period;
    TMP_P = _inv_peak;
    TMP_HP = _inv_hpeak;
    TMP_DEAD = _inv_deadtime;
//*************************************************
// MTU3 MTU4 相補PWMモード初期化
// Timer_Set_MTU;	// MTU3,MTU4 初期化
//*************************************************  
    //Wakeup MTU3
    MSTP(MTU3)=0;				// モジュールストップ解除 MTU3,MTU4
    MTU.TSTRA.BIT.CST3 = 0;			// MTU3タイマ―カウンタ(TCNT)の動作停止
    MTU.TSTRA.BIT.CST4 = 0;			// MTU4タイマ―カウンタ(TCNT)の動作停止
    // Counts on PCLK/1
     MTU3.TCR.BYTE=0x00;			// @@? 180523 AKI
     MTU4.TCR.BYTE=0x00;			// @@? 180523 AKI
    // Counts on PCLK/1　タイマーコントロールレジスタ(TCR)設定
    //MTU3.TCR.BIT.TPSC=0x0;			// TCNTのクリア禁止
    //MTU3.TCR.BIT.CCLR=0x0;			// TCNTは立ち上がりエッジでカウント
    //MTU3.TCR.BIT.CKEG=0x1;			// TCNTは内部クロックICLKでカウント(0x01：ICLK/4)
    //MTU4.TCR.BIT.TPSC=0x0;			// TCNTのクリア禁止
    //MTU4.TCR.BIT.CCLR=0x0;			// TCNTは立ち上がりエッジでカウント
    //MTU4.TCR.BIT.CKEG=0x1;			// TCNTは内部クロックICLKでカウント(0x01：ICLK/4)
    // Initialization of the 16bit counter
    MTU3.TCNT = _inv_deadtime; 			// MTU3 カウンタ初期値 dt
    MTU4.TCNT = 0;				// MTU4 カウンタ初期値 0
    
    //PWM Duty set
    MTU3.TGRB =i_period/2 ;		// 
    MTU4.TGRA =i_period/2 ; 
    MTU4.TGRB =i_period/2 ; 
    MTU3.TGRD =i_period/2 ;		// バッファレジスタ
    MTU4.TGRC =i_period/2 ;
    MTU4.TGRD =i_period/2 ; 
    //MTU3.TGRB = duty;				// i_period*0.46;//
    //MTU4.TGRA = duty-500;			// i_period*0.46-500;//
    //MTU4.TGRB = duty-1000;			// i_period*0.46-1000;//
    //MTU3.TGRD = duty;				// i_period*0.46;//
    //MTU4.TGRC = duty-500;			// i_period*0.46-500;//
   // MTU4.TGRD = duty-1000;			// i_period*0.46-1000;//
   
    // Dead time set 
    MTU.TDDRA = _inv_deadtime; 			// デッドタイムデータレジスタ
   
   // half the PWM carrier cycle 
    MTU.TCBRA = i_period;			// コンペアマッチレジスタ
    MTU.TCDRA = i_period;			// バッファレジスタ
   // half the PWM carrier cycle + Dead time
    MTU3.TGRA = i_period + _inv_deadtime;	// コンペアマッチレジスタ
    MTU3.TGRC = i_period + _inv_deadtime;	// バッファレジスタ
    // Timer Output control
    MTU.TOCR1A.BIT.PSYE = 1;			// トグル出力許可
    MTU.TOCR1A.BIT.TOCL=0;			// OLSNビット、OLSPビットへの書き込みを許可
    MTU.TOCR1A.BIT.OLSP=1;			// 正相の出力 初期LOW アクティブHIGH
    MTU.TOCR1A.BIT.OLSN=1;			// 逆相の出力 初期LOW アクティブHIGH
    // Set PWM mode 3
    MTU3.TMDR.BIT.MD = 0xf;			// 相補PWMモード３　山・谷で転送 0604
    MTU4.TMDR.BYTE = 0x00;			// @@? 180523
    // Buffer is enabled
    MTU3.TMDR.BIT.BFA = 1;			// TGRA , TGRC バッファ動作
    MTU3.TMDR.BIT.BFB = 1;			// TGRB , TGRD バッファ動作
    MTU4.TMDR.BIT.BFA = 0;			// @@? 180523
    MTU4.TMDR.BIT.BFB = 0;			// @@? 180523
    // タイマアウトプットマスタイネーブルレジスタの設定
    MTU.TOERA.BIT.OE3B=1;
    MTU.TOERA.BIT.OE4A=1;
    MTU.TOERA.BIT.OE4B=1;
    MTU.TOERA.BIT.OE3D=1;
    MTU.TOERA.BIT.OE4C=1;
    MTU.TOERA.BIT.OE4D=1;
    MTU.TSTRA.BIT.CST3 = 1;			// MTU3タイマ―カウンタ(TCNT)の動作イネーブル
    MTU.TSTRA.BIT.CST4 = 1;			// MTU4タイマ―カウンタ(TCNT)の動作イネーブル
//*************************************************
// MTU6 MTU7 相補PWMモード初期化
// Timer_Set_MTU;	// MTU3,MTU4 初期化
//*************************************************  
    //Wakeup MTU6
    MSTP(MTU6)=0;
    MTU.TSTRB.BIT.CST6 = 0;			// MTU6タイマ―カウンタ(TCNT)の動作停止
    MTU.TSTRB.BIT.CST7 = 0;			// MTU7タイマ―カウンタ(TCNT)の動作停止
    // Counts on PCLK/1　タイマーコントロールレジスタ(TCR)設定
    MTU6.TCR.BYTE=0x00;				// @@? 180523
    MTU7.TCR.BYTE=0x00;				// @@? 180523
    // Initialization of the 16bit counter
    MTU6.TCNT = _inv_deadtime; 			// MTU6 カウンタ初期値 dt
    MTU7.TCNT = 0;				// MTU7 カウンタ初期値 0
   
    // set PWM Duty    
    MTU6.TGRB = i_period/2;			// コンペアマッチレジスタ 
    MTU7.TGRA = i_period/2; 
    MTU7.TGRB = i_period/2;
    MTU6.TGRD = i_period/2;  //B 0629
    MTU7.TGRC = i_period/2; 
    MTU7.TGRD = i_period/2; 
    //MTU6.TGRB = duty-2000;			// i_period*0.46-2000=200
    //MTU7.TGRA = duty-1000;			// i_period*0.46-1000=1200
    //MTU7.TGRB = duty-500;			// i_period*0.46-500=1700
    //MTU6.TGRD = duty-2000;			// i_period*0.46-2000=200
    //MTU7.TGRC = duty-1000;			// i_period*0.46-1000=1200
    //MTU7.TGRD = duty-500;			// i_period*0.46-500=1700
    
     // Dead time 
    MTU.TDDRB = _inv_deadtime; 			// デッドタイムデータレジスタ
    // half the PWM carrier cycle
    MTU.TCBRB = i_period;			// コンペアマッチレジスタ
    MTU.TCDRB = i_period;			// バッファレジスタ
    // half the PWM carrier cycle + Dead time
    MTU6.TGRA = i_period + _inv_deadtime;	// コンペアマッチレジスタ
    MTU6.TGRC = i_period + _inv_deadtime;	// バッファレジスタ
    // Timer Output control
    MTU.TOCR1B.BIT.PSYE = 1;			// トグル出力許可
    MTU.TOCR1B.BIT.TOCL=0;			// OLSNビット、OLSPビットへの書き込みを許可
    MTU.TOCR1B.BIT.OLSP=1;			// 正相の出力 初期LOW アクティブHIGH
    MTU.TOCR1B.BIT.OLSN=1;			// 逆相の出力 初期LOW アクティブHIGH
    // Set PWM mode 3
    MTU6.TMDR.BIT.MD= 0xf;//0604
    MTU7.TMDR.BYTE = 0x00;
    // Buffer is enabled
    MTU6.TMDR.BIT.BFA = 1;			// TGRA , TGRC バッファ動作
    MTU6.TMDR.BIT.BFB = 1;			// TGRB , TGRD バッファ動作
    MTU7.TMDR.BIT.BFA = 0;			// @@? 180523 AKI
    MTU7.TMDR.BIT.BFB = 0;			// @@? 180523 AKI
    // タイマアウトプットマスタイネーブルレジスタの設定
    MTU.TOERB.BIT.OE6B = 1;
    MTU.TOERB.BIT.OE7A = 1;
    MTU.TOERB.BIT.OE7B = 1;
    MTU.TOERB.BIT.OE6D = 1;
    MTU.TOERB.BIT.OE7C = 1;
    MTU.TOERB.BIT.OE7D = 1;
    
    MTU.TSTRB.BIT.CST6 = 1;			// MTU6タイマ―カウンタ(TCNT)の動作イネーブル
    MTU.TSTRB.BIT.CST7 = 1;			// MTU7タイマ―カウンタ(TCNT)の動作イネーブル
    

/*************************************************/
    // 同期設定
     //MTU.TSYRA.BYTE = 0xC6;	// MTU1とMTU2,MTU3とMTU4を同期設定
     MTU.TSYRA.BYTE = 0x06;	// MTU1とMTU2を同期設定 0604
    //MTU.TSYRB.BYTE = 0xC0;	// MTU6とMTU7を同期設定 0604   
    // 外部信号で出力相を切り替え設定
    MTU.TGCRA.BIT.FB = 0;
    //*****************************
    //*      MTU キャプチャ設定   *
    //*******↓ここから************
    // MOTOR-1
    MTU0.TCR.BYTE = 0x03;	// ↑MTU0, TCNTのクリア禁止，1/64 プリスケーラ
    //MTU0.TCR.BYTE = 0x06;	// ↑MTU0, TCNTのクリア禁止，外部クロック：MTCLKC 端子入力でカウント
    MTU0.TIORH.BYTE = 0x0A;	// ↑MTIOC0A,↑MTIOC0B 両エッジでインプットキャプチャ0xA0
    MTU0.TIORL.BYTE = 0xAA;	// ↑MTIOC0C, 両エッジでインプットキャプチャ
    //R_PG_Timer_StartCount_MTU_U0_C0();	// タイマーSTART
     // MOTOR-2
    MTU1.TCR.BYTE = 0x03;	// ↑MTU0, TCNTのクリア禁止，1/64 プリスケーラ 
    MTU2.TCR.BYTE = 0x03;	// ↑MTU1, TCNTのクリア禁止，1/64 プリスケーラ
    //MTU1.TCR.BYTE = 0x06;	// ↑MTU0, TCNTのクリア禁止，1/256 プリスケーラ 
    //MTU2.TCR.BYTE = 0x06;	// ↑MTU1, TCNTのクリア禁止，外部クロック：MTCLKC 端子入力でカウント
    MTU1.TIOR.BYTE = 0xAA;	// ↑MTIOC1A,↑MTIOC1B 両エッジでインプットキャプチャ
    MTU2.TIOR.BYTE = 0x0A;	// ↑MTIOC2A 両エッジでインプットキャプチャ
    // Count Start
    MTU.TSTRA.BYTE = 0x01;	// タイマーSTART MTU0  0526 0x01
    MTU.TCSYSTR.BYTE = 0x7B;	// MTU1,2とMTU3,4とMTU6,7を同時スタート設定
   // MTU.TCSYSTR.BYTE = 0x60;	// MTU1,2とMTU3,4とMTU6,7を同時スタート設定
}

void  inverter_set_uvw(float u, float v, float w, unsigned short YT_cnt, unsigned short MN)
{
    int   itemp;
    
    //countc1++;
    
    /* U相のタイマーセット */
    itemp = (int) ((-u+1.0)*((float)_inv_hpeak)+((float)_inv_deadtime));
    
    if(YT_cnt==1)  /* 谷：上限が低い */
    {
    	if (itemp>(_inv_peak))
	{  itemp = _inv_peak;  }
    	else
	{
		if (itemp<0){  itemp = 0;  }
    		else{ }
	}
    }
    else  /* 山：上限が高い */
    {
    	if (itemp>(_inv_peak + _inv_deadtime))
	{  itemp = _inv_peak + _inv_deadtime;  }
    	else
	{
		if (itemp<_inv_deadtime){  itemp = _inv_deadtime;  }
    		else{ }
	}   
    }
    if(MN == 0)
    {
	MTU3.TGRB = itemp;	// M-1 PWM出力１　コンペアレジスタ	@*****
	MTU3.TGRD = itemp;
    }
    else
    {
	MTU6.TGRB = itemp;
	MTU6.TGRD = itemp;// M-2 PWM出力１　コンペアレジスタ	@*****
    }
    itemp_u = itemp;
    
   /* V相のタイマーセット */
    itemp = (int) ((-v+1.0)*((float)_inv_hpeak)+((float)_inv_deadtime));
    
    if(YT_cnt==1)  /* 谷：上限が低い */
    {
    	if (itemp>(_inv_peak))
	{  itemp = _inv_peak;  }
    	else
	{
		if (itemp<0){  itemp = 0;  }
    		else{ }
	}
    }
    else  /* 山：上限が高い */
    {
    	if (itemp>(_inv_peak + _inv_deadtime))
	{  itemp = _inv_peak + _inv_deadtime;  }
    	else
	{
		if (itemp<_inv_deadtime){  itemp = _inv_deadtime;  }
    		else{ }
	}   
    }
    if(MN == 0)
    {
	MTU4.TGRA = itemp;	// M-1 PWM出力２　コンペアレジスタ	@*****
	MTU4.TGRC = itemp;

    }
    else
    {
	MTU7.TGRA = itemp;	// M-2 PWM出力２　コンペアレジスタ	@*****
	MTU7.TGRC = itemp;
	
    }
    itemp_v = itemp;    
    
    
   /* W相のタイマーセット */
    itemp = (int) ((-w+1.0)*((float)_inv_hpeak)+((float)_inv_deadtime));
    
    if(YT_cnt==1)  /* 谷：上限が低い */
    {
    	if (itemp>(_inv_peak))
	{  itemp = _inv_peak;  }
    	else
	{
		if (itemp<0){  itemp = 0;  }
    		else{ }
	}
    }
    else  /* 山：上限が高い */
    {
    	if (itemp>(_inv_peak + _inv_deadtime))
	{  itemp = _inv_peak + _inv_deadtime;  }
    	else
	{
		if (itemp<_inv_deadtime){  itemp = _inv_deadtime;  }
  		else{ }
	}   
    }
    if(MN == 0)
    {
	MTU4.TGRB = itemp;	// M-1 PWM出力３　コンペアレジスタ	@*****
	MTU4.TGRD = itemp;
    }
    else
    {
	MTU7.TGRB = itemp;	// M-2 PWM出力３　コンペアレジスタ	@*****
	MTU7.TGRD = itemp;
    }
    itemp_w = itemp;        
    
}
void  inverter_set_uvw_2(float u, float v, float w, unsigned short YT_cnt_2, unsigned short MN)
{
    int   itemp;
    
   // countc2++;
    
    /* U相のタイマーセット */
    itemp = (int) ((-u+1.0)*((float)_inv_hpeak)+((float)_inv_deadtime));
    
    if(YT_cnt_2==1)  /* 谷：上限が低い */
    {
    	if (itemp>(_inv_peak))
	{  itemp = _inv_peak;  }
    	else
	{
		if (itemp<0){  itemp = 0;  }
    		else{ }
	}
    }
    else  /* 山：上限が高い */
    {
    	if (itemp>(_inv_peak + _inv_deadtime))
	{  itemp = _inv_peak + _inv_deadtime;  }
    	else
	{
		if (itemp<_inv_deadtime){  itemp = _inv_deadtime;  }
    		else{ }
	}   
    }
    if(MN == 0)
    {
	MTU3.TGRB = itemp;	// M-1 PWM出力１　コンペアレジスタ	@*****
	MTU3.TGRD = itemp;
    }
    else
    {
	MTU6.TGRB = itemp;
	MTU6.TGRD = itemp;// M-2 PWM出力１　コンペアレジスタ	@*****
    }
    itemp_u = itemp;
    
   /* V相のタイマーセット */
    itemp = (int) ((-v+1.0)*((float)_inv_hpeak)+((float)_inv_deadtime));
    
    if(YT_cnt_2==1)  /* 谷：上限が低い */
    {
    	if (itemp>(_inv_peak))
	{  itemp = _inv_peak;  }
    	else
	{
		if (itemp<0){  itemp = 0;  }
    		else{ }
	}
    }
    else  /* 山：上限が高い */
    {
    	if (itemp>(_inv_peak + _inv_deadtime))
	{  itemp = _inv_peak + _inv_deadtime;  }
    	else
	{
		if (itemp<_inv_deadtime){  itemp = _inv_deadtime;  }
    		else{ }
	}   
    }
    if(MN == 0)
    {
	MTU4.TGRA = itemp;	// M-1 PWM出力２　コンペアレジスタ	@*****
	MTU4.TGRC = itemp;

    }
    else
    {
	MTU7.TGRA = itemp;	// M-2 PWM出力２　コンペアレジスタ	@*****
	MTU7.TGRC = itemp;
	
    }
    itemp_v = itemp;    
    
    
   /* W相のタイマーセット */
    itemp = (int) ((-w+1.0)*((float)_inv_hpeak)+((float)_inv_deadtime));
    
    if(YT_cnt_2==1)  /* 谷：上限が低い */
    {
    	if (itemp>(_inv_peak))
	{  itemp = _inv_peak;  }
    	else
	{
		if (itemp<0){  itemp = 0;  }
    		else{ }
	}
    }
    else  /* 山：上限が高い */
    {
    	if (itemp>(_inv_peak + _inv_deadtime))
	{  itemp = _inv_peak + _inv_deadtime;  }
    	else
	{
		if (itemp<_inv_deadtime){  itemp = _inv_deadtime;  }
  		else{ }
	}   
    }
    if(MN == 0)
    {
	MTU4.TGRB = itemp;	// M-1 PWM出力３　コンペアレジスタ	@*****
	MTU4.TGRD = itemp;
    }
    else
    {
	MTU7.TGRB = itemp;	// M-2 PWM出力３　コンペアレジスタ	@*****
	MTU7.TGRD = itemp;
    }
    itemp_w = itemp;        
    
}

void  inverter_start_int(void)
{
//  MTU3
    // TGIEA of MTU3 interrupt is enabled
   // MTU3.TIER.BIT.TGIEA = 1;	// MPU3 TGIA 許可 vect=129
  //  IEN(MTU3,TGIA3) = 1;	// MPU3 山割込み TGIA3 許可
   // IPR(MTU3,TGIA3) = 15;	// プライオリティ
   // set_psw(0x00010000);
    //IEN(MTU3,TCIV3) = 1;	// MPU3 山割込み TGIA3 許可
    //IPR(MTU3,TCIV3) = 3;	// プライオリティ
    
    
    MTU4.TIER.BIT.TCIEV = 1;	// MPU4 TCIEV 許可 vect=134
   
    IEN(MTU4,TCIV4) = 1;	// MPU4 山谷割込み TCIV4 許可
    IPR(MTU4,TCIV4) = 15;	// プライオリティ*/
    /*IEN(MTU4,TGIA4) = 1;	// MPU4 谷割込み TGIA4 許可
    IPR(MTU4,TGIA4) = 3;	// プライオリティ
   // MTU4.TIER.BIT.TTGE2=1; */ 
    
   // MTU6.TIER.BIT.TGIEA = 1;	// MPU6 TGIA 許可 vect=142
   // IEN(MTU6,TGIA6) = 1;	// MPU6 山割込み TGIA6 許可
   // IPR(MTU6,TGIA6) = 15;	// プライオリティ
    //set_psw(0x00010000);
    
    MTU7.TIER.BIT.TCIEV = 1;	// MPU7 山谷割込み　TCIEV 許可 vect=149
   
    IEN(MTU7,TCIV7) = 1;	// MPU7 谷割込み TCIV7 許可
    IPR(MTU7,TCIV7) = 15;	// プライオリティ
    /*IEN(MTU7,TGIA7) = 1;	// MPU7 谷割込み TGIA7 許可
    IPR(MTU7,TGIA7) = 3;	// プライオリティ
    MTU7.TIER.BIT.TTGE2=1; */
}

void  inverter_stop_int(void)
{
//  TGIEA of MTU3 interrupt is desabled
   /* MTU3.TIER.BIT.TGIEA = 0;	// MPU3 TGIA 禁止
    MTU4.TIER.BIT.TGIEA = 0;	// MPU4 TGIA 禁止
    MTU6.TIER.BIT.TGIEA = 0;	// MPU6 TGIA 禁止
    MTU7.TIER.BIT.TGIEA = 0;	// MPU7 TGIA 禁止*/
//  ICU.IER[0x10].BIT.IEN1  =0;	// MPU3山割込み TGIA3 禁止
//  ICU.IER[0x11].BIT.IEN2  =0;	// MPU3谷割込み TCIV4 禁止
//  ICU.IER[0x11].BIT.IEN6  =0;	// MPU6山割込み TGIA6 禁止
//  ICU.IER[0x13].BIT.IEN1  =0;	// MPU6谷割込み TCIV7 禁止
    MTU3.TGRB =0.1;		// 
    MTU4.TGRA =0.1 ; 
    MTU4.TGRB =0.1 ; 
    MTU3.TGRD =0.1 ;		
    MTU4.TGRC =0.1 ;
    MTU4.TGRD =0.1 ; 
    MTU3.TGRA=0.1;
    MTU3.TGRC=0.1;
}



