
/***********************************************************************/
/*  VECT001  Vector Control with Hole IC Sensors                       */
/*  FILE        :testt.c                                               */
/*  DATE        :                                                      */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :RX62T                                                 */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.53).    */
/*  NOTE:THIS IS A BLDCM driver EXAMPLE.                               */
/*                                  2018.11.25 Geared Motor with Kyori */
/***********************************************************************/

#include "iodefine.h"
#include "ics_rx62t_uart0.h"
//#include "R_PG_Timer_MTU_U0_C3.h"	// MO_2
#include <machine.h>
#include <math.h>
#include "iolib.h"
#include "testt.h"
#include "define.h"

//Add typedefine.h for portability 
#include "typedefine.h"


// DTCのテーブルエリアを確保(0x1000からにSectionを確保している)
#pragma section DTCTABLE
unsigned long dtc_table[256]; // caution allignment 0x000
#pragma section

volatile unsigned long countc1=0, count1p=0, count1s=0;
volatile unsigned short cflag1, cflag2;
volatile unsigned long countc2=0, count2p=0, count2s=0;

// HALL IC ENCODE TABLE
static const _UBYTE TbUVW[8] = {1, 2, 4, 3, 6, 1, 5, 1};
// RUN CONTROL FLAG
volatile _UBYTE Run = 0;
// Accelaration limit := 100 RPM/SECOND
volatile _FLOAT dS_dt = (1000.0 / 20000);//100.0
//float dS_dt = (100.0 / 20000);
//*****************************************************************************
//*****************************************************************************
// MOTOR-1 MOTOR-2共通
//*****************************************************************************
//@****************************************************************************
// 共通
unsigned short MN;	// MOTOR NO. M-1=0 M-2=1
// Nrpm 計算定数 cNrpm_P=60/8*cIMCLK_FRQ*1000000/cTr2=1125000; cPole=8;cTr2=64;cIMCLK_FRQ=96[MHz]
//signed	int	cNrpm_P = 60 * cIMCLK_FRQ * 1000 / cTr2 / cPole * 1000;	// cNrpm_P = 1125000
signed	int	cNrpm_P = 10 * cIMCLK_FRQ * 1000 / (cPole/2 ) ;	//2 // cNrpm_P = 1125000
//signed	int	cNrpm_P = 1125000;
// f 計算定数 cF_P=cPole/60/2; cPole=8;
float	cF_P = cPole / 120.;  				// cF_P = cPole/60/2=0.066666666667;
// サンプル開始までのずれ角計算定数 cdt_P=cTr2/cIMCLK_FRQ/1000000; cTr2=64; IMCLK_FRQ=96[MHz]
//float	cdt_P = cTr2 / cIMCLK_FRQ / 1000000.;		// cdt_P = cTr2/96[MHz]=0.0000007
float	cdt_P = cTr2/ 96.0 / 1000000.;
/************value ctl*******/
//float  Rcnt=0,Rcnt_2=0;
float  ydiv=4096.0,xdiv=4096.0;//3800.0;
float   ave=2200.0;      //JOYSTICK average 600
float dp1=1.0,dp2=1.0,dpr1=1.5,dpr2=2.5,Rotp=2.0;  //Wheel Power
float jth = 0.05,jthx=0.05,jthr=0.10,pth=0.0;//0.035
float kaitensu=5.0,kaiten,kaiten_2;
float Power1,Power2,PowerN,PowerP,PowerPP,PowerPPP;
float Lp,Rp;

unsigned short jNorm=1,Rot=1,jNorm_2=1,Rot_2=1;
//unsigned short init=1,init_2=1,initm1=1,initm2=1;
unsigned short kdiv=1,F0=0,F1=0,B0=0,B1=0,jiro=0,kyori;
unsigned int  count;
unsigned short ov6,ud7,ov3,ud4;
unsigned short cngs=1;

float   fy=0,fx=0,fya=0,fxa=0,fyi=1600,fxi=2200;
float   fy_2=0,fx_2=0,fya_2=0,fxa_2=0,fyi_2=1600,fxi_2=2000;
float vr2_adi,Rotatei,vr2_adi_2,Rotatei_2,LPF_ad_1=0.001,LPF_ad_2=0.001;
volatile int iu,iv,iw;
float tmp_vr1;
/******Current CTL at mode*****/
/*float Start=5.5;//0.7
float St6=6.5;  // 0.4
float StV=6.5; //0.35*/
/******************************/

/* **************** */
/*      PLL制御     */
/* **************** */
// MOTOR-1
#ifdef KIK_256				// 吉慶モータ選択
/*float	kpPLL = 60.0;	/* 比例ゲイン 40[rad/s] 40*/
/*float	kiPLL =0.05;	/* 積分ゲイン 40[rad/s] (Kp/5)ωc×Ts 0.015 */
//float	kpPLL = 40.0;	/* 比例ゲイン 20[rad/s] 20*/
//float	kiPLL =0.005;	/* 積分ゲイン 20[rad/s] (Kp/5)ωc×Ts */
//float	kpPLL = 40.0;	/* 比例ゲイン 20[rad/s] 40*/
//float	kiPLL =0.05;	/* 積分ゲイン 20[rad/s] (Kp/5)ωc×Ts 0.05 */
//float	kpPLL = 70.0;	/* 比例ゲイン 40[rad/s] 40*/
//float	kiPLL =0.065;	/* 積分ゲイン 40[rad/s] (Kp/5)ωc×Ts */
//float	kpPLL = 100.0;	/* 比例ゲイン 100[rad/s]*/
//float	kiPLL =0.035;	/* 積分ゲイン 100[rad/s] (Kp/5)ωc×Ts */
//float	kpPLL_2 =70.0;	/* 比例ゲイン 200[rad/s] 70*/
//float	kiPLL_2 =0.065;	/* 積分ゲイン 200[rad/s] 0.065(Kp/5)ωc×Ts *0.08/
//float	kpPLL_2 =40.0;	/* 比例ゲイン 300[rad/s]*/
//float	kiPLL_2 =0.05;	/* 積分ゲイン 300[rad/s] (Kp/5)ωc×Ts */
float	kpPLL = 40.0;
float	kiPLL =0.02;//0.0015
//MOTOR-2
float	kpPLL_2 = 10.0;
float	kiPLL_2 =0.001;
#endif

#ifdef BLY171S				// BLY171Sモータ選択
/*float	kpPLL = 40.0;	/* 比例ゲイン 100[rad/s]*/
/*float	kiPLL =0.015;	/* 積分ゲイン 100[rad/s] (Kp/5)ωc×Ts */
float	kpPLL = 100.0;	/* 比例ゲイン 100[rad/s]*/
float	kiPLL =0.1;	/* 積分ゲイン 100[rad/s] (Kp/5)ωc×Ts */
/*float	kpPLL = 200.0;	/* 比例ゲイン 200[rad/s]*/
/*float	kiPLL =0.4;	/* 積分ゲイン 200[rad/s] (Kp/5)ωc×Ts */
/*float	kpPLL = 300.0;	/* 比例ゲイン 300[rad/s]*/
/*float	kiPLL =0.8;	/* 積分ゲイン 300[rad/s] (Kp/5)ωc×Ts */
/*float	kpPLL = 400.0;	/* 比例ゲイン 400[rad/s]*/
/*float	kiPLL =1.6;	/* 積分ゲイン 400[rad/s] (Kp/5)ωc×Ts */
#endif

/* **************** */
/*     電流制御     */
/* **************** */
// MOTOR-1
#ifdef KIK_256				// 吉慶モータ選択
//float	kpACR = 0.01165;	/* 比例ゲイン 50[rad/s]*/
//float	kiACR = 0.0002825;	/*  0.0005825;*/
//float	kpACR = 0.0233;	/* 比例ゲイン 100[rad/s]*/
//loat	kiACR = 0.00133;	/* 積分ゲイン 100[rad/s] 2018.4.16 変更*/
float	kpACR = 0.0665;	//0.0865
float	kiACR = 0.00165;//0.00165
/*float	kpACR = 0.0930;
/*float	kiACR = 0.00330;
/*float	kpACR = 0.003;	/* 比例ゲイン 800[rad/s]*/
/*float	kiACR = 0.00001;	/* 積分ゲイン 800[rad/s] 2018.4.16 変更*/
/*float	kpACR = 0.3720;	/* 比例ゲイン 1600[rad/s]*/
/*float	kiACR = 0.3720;	/* 積分ゲイン 1600[rad/s] 2018.4.16 変更*/
//MOTOR-2
float	kpACR_2 = 0.0665;//0.0865
float	kiACR_2 = 0.00165;//0.00165
#endif

#ifdef BLY171S				// BLY171Sモータ選択
float	kpACR = 0.0633;	/* 比例ゲイン 100[rad/s]*/
float	kiACR = 0.00165;/* 積分ゲイン 100[rad/s] 2018.4.16 削除*/
/*float	kpACR = 0.0465;	/* 比例ゲイン 200[rad/s]*/
/*float	kiACR = 0.00233;/* 積分ゲイン 200[rad/s] 2018.4.16 削除*/
/*float	kpACR = 0.0930;	/* 比例ゲイン 400[rad/s]*/
/*float	kiACR = 0.00465;/* 積分ゲイン 400[rad/s] 2018.4.16 削除*/
/*float	kpACR = 0.1860;	/* 比例ゲイン 800[rad/s]*/
/*float	kiACR = 0.00930;/* 積分ゲイン 800[rad/s] 2018.4.16 削除*/
/*float	kpACR = 0.3720;	/* 比例ゲイン 1600[rad/s]*/
/*float	kiACR = 0.01860;/* 積分ゲイン 1600[rad/s] 2018.4.16 削除*/
#endif

/* **************** */
/*     速度制御     */
/* **************** */
// MOTOR-1 MOTOR-2
float	Nref1 = cNref1;		// 速度指令最大値 250[rpm]	@@ 180529
float	N_LOW_MAX = cN_LOW_MAX;	// 最低速度 2[rpm]		@@ 180529

#ifdef KIK_256				// 吉慶モータ選択
//float	kpASR = 0.0637;		/* 比例ゲイン 40[rad/s]*/
//float	kiASR = 0.000235;	/* 積分ゲイン 40[rad/s] 2018.4.16 変更*/
float	kpASR = 0.55;	/* 比例ゲイン 5[rad/s]*/
float	kiASR = 0.015;	/* 積分ゲイン 5[rad/s] 2018.4.16 変更*/
/*float	kpASR = 0.01540;	/* 比例ゲイン 10[rad/s]*/
/*float	kiASR = 0.0001;	/* 積分ゲイン 10[rad/s] 2018.4.16 変更*/
/*float	kpASR = 0.0108;		/* 比例ゲイン 20[rad/s]*/
/*float	kiASR = 0.0000431;	/* 積分ゲイン 20[rad/s] 2018.4.16 変更*/
/*float	kpASR = 0.00216;	/* 比例ゲイン 40[rad/s]*/
/*float	kiASR = 0.0001727;	/* 積分ゲイン 40[rad/s] 2018.4.16 変更*/
//MOTOR-2
//float	kpASR_2 = 0.0637;		/* 比例ゲイン 40[rad/s]*/
//float	kiASR_2 = 0.000235;
float	kpASR_2 = 0.55;
float	kiASR_2 = 0.015;/* 積分ゲイン 5[rad/s] 2018.4.16 変更*/
/******************************/
float	dN_HI_P = 0.1;	/* 加速レイト 5000 5.0  0.000112.0*/
float	dN_HI_N = 0.1;	/* 減速レイト 5000 5.0  0.000112.0*/
//float	dN_HI_P = (5000*0.00005)/10.0;	/* 加速レイト 5000[rpm]に達する時間 0.5s =0.0025
//float	dN_HI_N = (5000*0.00005)/10.0;	/* 減速レイト 5000[rpm]に達する時間 0.5s*/
//float	dN_HI_P = (8000*0.00005)/10.0;	/* 加速レイト 8000[rpm]に達する時間 0.5s =0.04
//float	dN_HI_N = (8000*0.00005)/10.0;	/* 減速レイト 8000[rpm]に達する時間 0.5s*/

#endif

#ifdef BLY171S				// BLY171Sモータ選択
float	kpASR = 0.00169;	/* 比例ゲイン 20[rad/s]*/
float	kiASR = 0.000000377;	/* 積分ゲイン 20[rad/s] 2018.4.16 */
/*float	kpASR = 0.000422;	/* 比例ゲイン 5[rad/s]*/
/*float	kiASR = 0.000000021;	/* 積分ゲイン 5[rad/s] 2018.4.16 */
/*float	kpASR = 0.000844;	/* 比例ゲイン 10[rad/s]*/
/*float	kiASR = 0.0000000844;	/* 積分ゲイン 10[rad/s] 2018.4.16 */
/*float	kpASR = 0.00337;	/* 比例ゲイン 40[rad/s]*/
/*float	kiASR = 0.0000270;	/* 積分ゲイン 40[rad/s] 2018.4.16 */

/*float	dN_HI_P = (8000*0.00005)/2.0; /* 加速レイト 8000*/
/*float	dN_HI_N = (8000*0.00005)/2.0; /* 減速レイト 8000 5.0*/
#endif

//*****************************************************************************
//*****************************************************************************
// MOTOR-1
//*****************************************************************************
//@****************************************************************************
unsigned short an000, an001, an102, an003,an103;
unsigned short anX1, anC01, anY1;

unsigned short anTMP;	/* ADのあてうま */

unsigned short YT_cnt = 1;	/* 山=0, 谷=1 */
unsigned short t_cnt = 0; /* キャプチャ間のcnt数 */

unsigned short TC_cnt_1A = 0; /* キャプチャの値 */
unsigned short TC_cnt_3A = 0; /* キャプチャの値 */
unsigned short TC_cnt_3C = 0; /* キャプチャの値 */
unsigned short TC_cnt_1A_1 = 0; /* キャプチャの値old */
unsigned short TC_cnt_3A_1 = 0; /* キャプチャの値old */
unsigned short TC_cnt_3C_1 = 0; /* キャプチャの値old */

unsigned int   cnt = 0;/* ICSに使用 */
unsigned int   ic = 0,ic_2=0;/* ido hekinに使用 */

float   m = 0;
float   iu_ad, iv_ad, iw_ad;
float   Vu_ad, Vv_ad, Vw_ad;
float   vr1_ad=0,vr2_ad=0;
float   f0=0,f0_2=0;
float   f1,f2,f3,f4,f1_2,f2_2,f3_2,f4_2;

float   ftau=0.0001,fdt=0.0001;
float   vdc_ad;
float   vrx1,vry1,vrc01,vrx2,vry2,vrc02;
float   Rotate,Rotate_2;
float   fr0,fr0_2;
float   fr1,fr2,fr3,fr4,fr1_2,fr2_2,fr3_2,fr4_2;
float   frtau,rfdt;

float   refu, refv, refw;
float   offset_u =0.5; /*0.295;/* Iuのオフセット値 */
float   offset_v =0.5; /*0.23;/* Ivのオフセット値 */
float   offset_w =0.5; /*0.23;/* Iwのオフセット値 */
float   refi = 0;
float   refs = 2.0f;
float   Ra   = 1.1f;
float   bmf  = 0;
float   Vout_est = 0;
float   Vout_ad  = 0;

float	Nrpm = 0;/* 回転数[r/min] */
float	Nrpm_1 = 0;/* 回転数[r/min]old  */
float	Nrpm_s = 0;/* 回転数[r/min]  */

/* ↓正弦波駆動に向けて追加 */

unsigned short TC_FLG = 0; /*  キャプチャあり/なし, 1/0  */
unsigned short TC_cnt_Ts = 0; /*  サンプル開始時のカウンタ値 */
unsigned short TC_cnt_Hole = 0; /*  キャプチャ時ののカウンタ値 */

float	Fe1 = 2.0;   /* 電気角周波数[Hz] */
float	We1 = 0.0;   /* 電気角周波数[rad/s] */
float	THdc = 0.0;  /* ｄ軸位相角θdc[rad] */
float	THdcV = 0.0;  /* ｄ軸位相dq逆変換用[rad] */
float	dTHdc = 0.0; /* サンプル期間の位相角 ω1・Ts  */

float	TH_hole = 0.0;  /* ホールIC位相角θhole[rad] */
float	dTH_hole = 0.0; /* ホール信号との補正位相 ω1・ΔTic  */

unsigned char  HUVW;/* サンプリング開始時のHole ICの状態 */
unsigned char  V_MODE = 1;/* PWMモード */
unsigned char  TH_sin_on = 1;/* Y150814 位相補間オン */
unsigned char  S6_MODE = 1,S5_MODE=1,S6_MODE_p=1.0;/* 0: -sin, 1:6step, 2:+sin */

float	Vdc0 = 0.0;   /* d軸電圧指令 */
float	Vqc0 = 0.0;   /* q軸電圧指令 */
float	Vac0 = 0.0;   /* a軸電圧指令 */
float	Vbc0 = 0.0;   /* b軸電圧指令 */
float	Vac0_t = 0.0;   /* a軸電圧指令 */
float	Vbc0_t = 0.0;   /* b軸電圧指令 */
float	Vuc0 = 0.0;   /* U相電圧指令 */
float	Vvc0 = 0.0;   /* V相電圧指令 */
float	Vwc0 = 0.0;   /* W相電圧指令 */

float	Vuc1 = 0.0;   /* U相修正後電圧指令 */
float	Vvc1 = 0.0;   /* V相修正後電圧指令 */
float	Vwc1 = 0.0;   /* W相修正後電圧指令 */
float 	Vzero = 0.0;   /* 零相補正電圧　*/

float	SIN0 = 0.0;  /* sinθの値 */
float	COS0 = 0.0;  /* cosθの値 */

unsigned short PWM_mode = 1;  /* 0:sinPWM, 1:HIP */
/* ↑ここまで */

unsigned char DRV_sts = 0;	/* ドライブステータス */

unsigned char  UVW;
unsigned char  U, V, W;
unsigned char  SW;
unsigned char  VMODE = 1;/* PWMモード */
unsigned char  VMODE_z1 = 1;/* PWMモード 1/z*/
unsigned char  VMODE_z2 = 1;/* PWMモード 1/z*/
unsigned char  R_DR = 1; /* R_DR -> 1:正転，0:逆転 */

unsigned short an003_1, an100_1, an101_1;/* 過去値 Y150614 */

//float power=1.4,power2=1.4;

float a_LPF_N,a_LPF_N_2;

/* **************** */
/*      PLL制御     */
/* **************** */
// MOTOR-1
float	THdc_err = 0.0;	/* Δθdc軸誤差 */

float	THdcPLL = 0.0;  /* PLL位相角θdc[rad] */
float	s_kiPLL = 0.0; /* 積分値の中身 */
float	W1PLL=0.0;

unsigned short  PLL_ON = 1;/* 位相のPLLオン */



/* **************** */
/*     電流制御     */
/* **************** */
// MOTOR-1
float	Iac0 = 0.0;/* α軸電流 */
float	Ibc0 = 0.0;/* β軸電流 */
float	Idc0 = 0.0;/* d軸電流 */
float	Iqc0 = 0.0;/* q軸電流 */



/* Rline=0.35ohm, Lline=0.35mH */
float	I_FB = 0; /* 検出電流 */
float	I_ref_d = 0; /* d軸電流指令 */
float	I_ref_q = 0; /* q軸電流指令 */
float	I_ref_ASR = 0.0; /* ASRの出力 */

float	I_ref_q_ini = 0.0;/* ASR初期値 */
float	I_REF0 = 0.5;
float	I_err_d = 0.0;	/* ｑ軸電流誤差 */
float	I_err_q = 0.0;	/* ｑ軸電流誤差 */

float	s_kiACR_d = 0.0; /* 積分値の中身 */
float	s_kiACR_q = 0.0; /* 積分値の中身 */
float	mtest = 0.0; /* 変調率指令テスト用 */

float	s_LPF_i = 0.0;	/* 電流検出用，一次遅れフィルタ */
float	k_LPF_i = 0.05; /* =Ts/Tf, Ts=0.00005,Tf=0.001 */

float	s_LPF_id0 = 0.0;	/* 一次遅れフィルタ */
float	k_LPF_id0 = 0.005; /* 0.001  =Ts/Tf, Ts=0.00005,Tf=0.001 0.05*/
float	s_LPF_iq0 = 0.0;	/* 一次遅れフィルタ */
float	k_LPF_iq0 = 0.005; /* =Ts/Tf, Ts=0.00005,Tf=0.001 0.05*/
float	s_LPF_vd0 = 0.0;	/* 一次遅れフィルタ */
float	k_LPF_vd0 = 0.005; /* =Ts/Tf, Ts=0.00005,Tf=0.001 0.05*/
float	s_LPF_vq0 = 0.0;	/* 一次遅れフィルタ */
float	k_LPF_vq0 = 0.005; /* =Ts/Tf, Ts=0.00005,Tf=0.001 0.05*/

/* **************** */
/*     速度制御     */
/* **************** */
// MOTOR-1
float	Nerr = 0.0;		/* 速度誤差 */
float	s_kiASR = 0.0;		/* 積分器中身 */
float	Nref0 = 0.0;		/* センサレス初期値 */
float	Nrpm_ref = 0.0;		/* 速度指令[r/min] */
float	Nrpm_ref0 = 0.0;	/* 速度指令[r/min] */

#define cTf	(0.1)	// Tf
float	s_LPF_N = 0.0;	/* 速度検出用，一次遅れフィルタ */
float	k_LPF_N = 0.0002; /* =Ts/Tf, Ts=0.0005,Tf=0.1 */
/*float	k_LPF_N = 0.025; /* =Ts/Tf, Ts=0.00005,Tf=0.002 */
/*float	k_LPF_N = 0.00250; /* =Ts/Tf, Ts=0.00005,Tf=0.020 */
/*float	k_LPF_N = 0.00125; /* =Ts/Tf, Ts=0.00005,Tf=0.040 */
//float	k_LPF_N = 0.0005; /* =Ts/Tf, Ts=0.00005,Tf=0.1 */

float	s_LPF_N2 = 0.0;	/* 位相補正用，一次遅れフィルタ */
float	k_LPF_N2 = 0.0002; /* =Ts/Tf, Ts=0.0005,Tf=0.1 */
/*float	k_LPF_N2 = 0.025; /* =Ts/Tf, Ts=0.00005,Tf=0.002 */
/*float	k_LPF_N2 = 0.01; /* =Ts/Tf, Ts=0.00005,Tf=0.005 */
/*float	k_LPF_N2 = 0.0025; /* =Ts/Tf, Ts=0.00005,Tf=0.020 */
//float	k_LPF_N2 = 0.0005; /* =Ts/Tf, Ts=0.00005,Tf=0.1 */
/*float	k_LPF_N2 = 0.0002; /* =Ts/Tf, Ts=0.00005,Tf=0.1 */

//*****************************************************************************
//*****************************************************************************
// MOTOT-2
//*****************************************************************************
//@****************************************************************************
unsigned short an000_2, an001_2, an102_2, an003_2,an103_2;
unsigned short anX2, anC02, anY2;
unsigned short anTMP;	/* ADのあてうま */

unsigned short YT_cnt_2 = 1;	/* 山=0, 谷=1 */
unsigned short t_cnt_2 = 0; /* キャプチャ間のcnt数 */
unsigned short TC_cnt_1A_2 = 0; /* キャプチャの値 */
unsigned short TC_cnt_3A_2 = 0; /* キャプチャの値 */
unsigned short TC_cnt_3C_2 = 0; /* キャプチャの値 */
unsigned short TC_cnt_1A_1_2 = 0; /* キャプチャの値old */
unsigned short TC_cnt_3A_1_2 = 0; /* キャプチャの値old */
unsigned short TC_cnt_3C_1_2 = 0; /* キャプチャの値old */

unsigned int   cnt_2 = 0;/* ICSに使用 */

float   m_2 = 0;
float   iu_ad_2, iv_ad_2, iw_ad_2;
float   Vu_ad_2, Vv_ad_2, Vw_ad_2;
float   vr1_ad_2=0,vr2_ad_2=0;
float   vdc_ad_2;
float   vrx2,vry2;

float   refu_2, refv_2, refw_2;
float   offset_u_2 =0.5; /*0.295;/* Iuのオフセット値 */
float   offset_v_2 =0.5; /*0.23;/* Ivのオフセット値 */
float   offset_w_2 =0.5; /*0.23;/* Iwのオフセット値 */
float   refi_2 = 0;
float   refs_2 = 2.0f;
float   Ra_2   = 1.1f;
float   bmf_2  = 0;
float   Vout_est_2 = 0;
float   Vout_ad_2  = 0;

float	Nrpm_2 = 0;/* 回転数[r/min] */
float	Nrpm_1_2 = 0;/* 回転数[r/min]old  */
float	Nrpm_s_2 = 0;/* 回転数[r/min]  */

/* ↓正弦波駆動に向けて追加 */

unsigned short TC_FLG_2 = 0; /*  キャプチャあり/なし, 1/0  */
unsigned short TC_cnt_Ts_2 = 0; /*  サンプル開始時のカウンタ値 */
unsigned short TC_cnt_Hole_2 = 0; /*  キャプチャ時ののカウンタ値 */

float	Fe1_2 = 2.0;   /* 電気角周波数[Hz] */
float	We1_2 = 0.0;   /* 電気角周波数[rad/s] */
float	THdc_2 = 0.0;  /* ｄ軸位相角θdc[rad] */
float	THdcV_2 = 0.0;  /* ｄ軸位相dq逆変換用[rad] */
float	dTHdc_2 = 0.0; /* サンプル期間の位相角 ω1・Ts  */

float	TH_hole_2 = 0.0;  /* ホールIC位相角θhole[rad] */
float	dTH_hole_2 = 0.0; /* ホール信号との補正位相 ω1・ΔTic  */

unsigned char  HUVW_2;/* サンプリング開始時のHole ICの状態 */
unsigned char  V_MODE_2 = 1;/* PWMモード */
unsigned char  TH_sin_on_2 = 1;/* Y150814 位相補間オン */
unsigned char  S6_MODE_2 = 1,S5_MODE_2=1,S6_MODE_2_p=1.0;;/* 0: -sin, 1:6step, 2:+sin */

float	Vdc0_2 = 0.0;   /* d軸電圧指令 */
float	Vqc0_2 = 0.0;   /* q軸電圧指令 */
float	Vac0_2 = 0.0;   /* a軸電圧指令 */
float	Vbc0_2 = 0.0;   /* b軸電圧指令 */
float	Vac0_t_2 = 0.0;   /* a軸電圧指令 */
float	Vbc0_t_2 = 0.0;   /* b軸電圧指令 */
float	Vuc0_2 = 0.0;   /* U相電圧指令 */
float	Vvc0_2 = 0.0;   /* V相電圧指令 */
float	Vwc0_2 = 0.0;   /* W相電圧指令 */

float	Vuc1_2 = 0.0;   /* U相修正後電圧指令 */
float	Vvc1_2 = 0.0;   /* V相修正後電圧指令 */
float	Vwc1_2 = 0.0;   /* W相修正後電圧指令 */
float 	Vzero_2 = 0.0;   /* 零相補正電圧　*/

float	SIN0_2 = 0.0;  /* sinθの値 */
float	COS0_2 = 0.0;  /* cosθの値 */

unsigned short PWM_mode_2 = 1;  /* 0:sinPWM, 1:HIP */
/* ↑ここまで */

unsigned char DRV_sts_2 = 0;	/* ドライブステータス */

unsigned char  UVW_2;
unsigned char  U_2, V_2, W_2;
unsigned char  SW_2;
unsigned char  VMODE_2 = 1;/* PWMモード */
unsigned char  VMODE_z1_2 = 1;/* PWMモード 1/z*/
unsigned char  VMODE_z2_2 = 1;/* PWMモード 1/z*/
unsigned char  R_DR_2 = 1; /* R_DR -> 1:正転，0:逆転 */

unsigned short an003_1_2, an100_1_2, an101_1_2;/* 過去値 Y150614 */

/* **************** */
/*      PLL制御     */
/* **************** */
float	THdc_err_2 = 0.0;	/* Δθdc軸誤差 */

float	THdcPLL_2 = 0.0;  /* PLL位相角θdc[rad] */
float	s_kiPLL_2 = 0.0; /* 積分値の中身 */
float	W1PLL_2=0.0;

unsigned short  PLL_ON_2 = 1;/* 位相のPLLオン */

/* **************** */
/*     電流制御     */
/* **************** */
float	Iac0_2 = 0.0;/* α軸電流 */
float	Ibc0_2 = 0.0;/* β軸電流 */
float	Idc0_2 = 0.0;/* d軸電流 */
float	Iqc0_2 = 0.0;/* q軸電流 */

/* Rline=0.35ohm, Lline=0.35mH */
float	I_FB_2 = 0; /* 検出電流 */
float	I_ref_d_2 = 0; /* d軸電流指令 */
float	I_ref_q_2 = 0; /* q軸電流指令 */
float	I_ref_ASR_2 = 0.0; /* ASRの出力 */

float	I_ref_q_ini_2 = 0.0;/* ASR初期値 */
float	I_REF0_2 = 0.5;
float	I_err_d_2 = 0.0;	/* ｑ軸電流誤差 */
float	I_err_q_2 = 0.0;	/* ｑ軸電流誤差 */

float	s_kiACR_d_2 = 0.0; /* 積分値の中身 */
float	s_kiACR_q_2 = 0.0; /* 積分値の中身 */
float	mtest_2 = 0.0; /* 変調率指令テスト用 */

float	s_LPF_i_2 = 0.0;	/* 電流検出用，一次遅れフィルタ */
float	k_LPF_i_2 = 0.05; /* =Ts/Tf, Ts=0.00005,Tf=0.001 */

float	s_LPF_id0_2 = 0.0;	/* 一次遅れフィルタ */
float	k_LPF_id0_2 = 0.05; /* =Ts/Tf, Ts=0.00005,Tf=0.001 */
float	s_LPF_iq0_2 = 0.0;	/* 一次遅れフィルタ */
float	k_LPF_iq0_2 = 0.05; /* =Ts/Tf, Ts=0.00005,Tf=0.001 */
float	s_LPF_vd0_2 = 0.0;	/* 一次遅れフィルタ */
float	k_LPF_vd0_2 = 0.05; /* =Ts/Tf, Ts=0.00005,Tf=0.001 */
float	s_LPF_vq0_2 = 0.0;	/* 一次遅れフィルタ */
float	k_LPF_vq0_2 = 0.05; /* =Ts/Tf, Ts=0.00005,Tf=0.001 */

/* **************** */
/*     速度制御     */
/* **************** */
float	Nerr_2 = 0.0;	/* 速度誤差 */

float	s_kiASR_2 = 0.0; /* 積分器中身 */
float	Nref0_2 = 0.0; /* センサレス初期値 */
float	Nrpm_ref_2 = 0.0; /* 速度指令[r/min] */
float	Nrpm_ref0_2 = 0.0; /* 速度指令[r/min] */

float	s_LPF_N_2 = 0.0;	/* 速度検出用，一次遅れフィルタ */
float	k_LPF_N_2 = 0.0001; /* =Ts/Tf, Ts=0.00005,Tf=0.002 */
/*float	k_LPF_N_2 = 0.00250; /* =Ts/Tf, Ts=0.00005,Tf=0.020 */
/*float	k_LPF_N_2 = 0.00125; /* =Ts/Tf, Ts=0.00005,Tf=0.040 */
/*float	k_LPF_N_2 = 0.0005; /* =Ts/Tf, Ts=0.00005,Tf=0.1 */

float	s_LPF_N2_2 = 0.0;	/* 位相補正用，一次遅れフィルタ */
/*float	k_LPF_N2_2 = 0.025; /* =Ts/Tf, Ts=0.00005,Tf=0.002 */
float	k_LPF_N2_2 = 0.0001; /* =Ts/Tf, Ts=0.00005,Tf=0.005 */
/*float	k_LPF_N2_2 = 0.0025; /* =Ts/Tf, Ts=0.00005,Tf=0.020 */
/*float	k_LPF_N2_2 = 0.0005; /* =Ts/Tf, Ts=0.00005,Tf=0.1 */

int  SpiRxDat;

/********RSPI Init*****************/
void RSPI_Init(void) //Master
{

    /* Cancel RSPI module stop state */
    MSTP(RSPI0) = 0; //enable RSPI
    //PWPR=0;
//RSPI0.SSLND.BIT.SLNDL = 0;
//Set input/output ports
    PORTD.DDR.BIT.B1=0; // MISO 1: output 0: input
//PORTA.ICR.BIT.B5=1; // 1: MISO pin = input

    PORTD.DDR.BIT.B0=1; // CLK 1: output 0: input
//PORTA.ICR.BIT.B4=1; // 1: CLK pin = input

    PORTD.DDR.BIT.B6=1; // CS (SSL0) 1: output 0: input
    PORTD.DDR.BIT.B7=1; // CS (SSL1) 1: output 0: input
//PORTA.ICR.BIT.B3=1; // 1: CS pin = input

    PORTD.DDR.BIT.B2=1; // MOSI 1: output 0: input
//PORTB.ICR.BIT.B0=1; // 1: MOSI pin = input

    IOPORT.PFHSPI.BIT.RSPIS=2; //select MOSI-C, MISO-C, CLK-C, SSL0-C
    IOPORT.PFGSPI.BIT.RSPCKE=1; //enable CLK
    IOPORT.PFGSPI.BIT.MISOE=0; //disable MISO disable
    IOPORT.PFGSPI.BIT.MOSIE=1; //enable MOSI
    IOPORT.PFGSPI.BIT.SSL0E=1; //enable CS
    IOPORT.PFGSPI.BIT.SSL1E=1; //enable CS



    /* Disable RSPI interrupts */
    IR(RSPI0,SPTI0)=0; //clear flag //Disable SPTI0 interrupt
    IR(RSPI0,SPRI0)=0; //clear flag //Disable SPRI0 interrupt


    /* Disable RSPI function */
    RSPI0.SPCR.BIT.SPE = 0;

//RSPI0.SPPCR.BYTE = 0x00;
    RSPI0.SPPCR.BIT.MOIFV=1; //MOSI idle =1
    RSPI0.SPPCR.BIT.MOIFE=1; //reset MOSI idle =1
    RSPI0.SPPCR.BIT.SPLP=0;
    RSPI0.SPPCR.BIT.SPLP2=0;

//Set the bit rate
    RSPI0.SPBR = 4; //5MHz
//RSPI0.SPBR.BYTE = 4;
    RSPI0.SPCMD0.BIT.CPOL=1;    //clock idle high
    RSPI0.SPCMD0.BIT.CPHA=1;    //data idle high

//Set MSB first. Set data length. Set clock phase. Set clock polarity.
    RSPI0.SPCMD0.BIT.CPHA = 0; //1: Data variation on falling edge, 0: data sampling on rising edge
    RSPI0.SPCMD0.BIT.CPOL = 1; //0: RSPCK = 0 when idle
    RSPI0.SPCMD0.BIT.BRDV = 0; //00: These bits select the base bit rate
    RSPI0.SPCMD0.BIT.SPB = 0xf; //f= 1 1 1 1: 16 bits
    RSPI0.SPCMD0.BIT.LSBF = 0; //0: MSB first

//Set slave mode. Set mode fault error detection. Set interrupt mask. Set RSPI mode
    RSPI0.SPCR.BIT.SPMS=0; //SPI mode
    RSPI0.SPCR.BIT.TXMD=1; //0: Full-duplex synchronous serial communications 1:send only
    RSPI0.SPCR.BIT.SPE=1; //enable SPI
    RSPI0.SPCR.BIT.MSTR=1; //0: slave mode 1: Master
    RSPI0.SPCR.BIT.MODFEN=0;
    RSPI0.SPCR.BIT.SPEIE=0;
    RSPI0.SPCR.BIT.SPTIE=0;
    RSPI0.SPCR.BIT.SPRIE=0;

    RSPI0.SPDCR.BIT.SLSEL=0; //out
    RSPI0.SPDCR.BIT.SPLW=0; //word acccsess

    RSPI0.SPCR.BYTE;

}
/******************************************************************************/

//*****************************************************************************
// ＵＶＷ入力１
//	UVW_in()
//*****************************************************************************
unsigned char UVW_in(void)
{
    unsigned char temp8;
    /*if(0.1>vr1_ad){
      temp8 = W_in();
      temp8 = (temp8+temp8) + V_in();
      temp8 = (temp8+temp8) + U_in();
    }*/
#if 0
    if(R_DR== 1) { //||(Rotate<-0.1)){//vr1_ad  0604-jth
        temp8 = U_in();                //U
        temp8 = (temp8+temp8) + W_in();//W
        temp8 = (temp8+temp8) + V_in();//V
    }
    else {}
    if(R_DR== 0 ) { //||(Rotate>0.1)){ //vr1_ad  0604 jth
        temp8 = W_in();                 //W
        temp8 = (temp8+temp8) + V_in(); //V
        temp8 = (temp8+temp8) + U_in(); //U
    }
    else {}
#else
    temp8 = W_in();                 //W
    temp8 = (temp8+temp8) + V_in(); //V
    temp8 = (temp8+temp8) + U_in(); //U

    temp8 = TbUVW[temp8];

    if(R_DR==1) {
        temp8 = ((temp8 + 2) % 6)+1 ;
       
    }
    else {}
#endif
    return temp8;
}

//*****************************************************************************
// ＵＶＷ入力２
//	UVW_in_m2()
//*****************************************************************************
unsigned char UVW_in_m2(void)
{
    unsigned char temp8;
    /*if(0.1>vr1_ad){
      temp8 = W_in();
      temp8 = (temp8+temp8) + V_in();
      temp8 = (temp8+temp8) + U_in();
    }*/
#if 0
    if(vr2_ad_2 <- jth) { //||(Rotate_2<-0.1)){ //vr1_ad_2 0604
        temp8 = U_in_m2();                //U
        temp8 = (temp8+temp8) + W_in_m2();//W
        temp8 = (temp8+temp8) + V_in_m2();//V
    }
    else {}
    if(vr2_ad_2 > jth) { //||(Rotate_2>0.1)){//vr1_ad_2 0604
        temp8 = W_in_m2();                 //W
        temp8 = (temp8+temp8) + V_in_m2(); //V
        temp8 = (temp8+temp8) + U_in_m2(); //U
    }
    else {}
#else
    temp8 = W_in_m2();                 //W
    temp8 = (temp8+temp8) + V_in_m2(); //V
    temp8 = (temp8+temp8) + U_in_m2(); //U

    temp8 = TbUVW[temp8];

    if(R_DR==1) {
        temp8 = ((temp8 + 2) % 6)+1 ;
       
    }
    else {}
#endif 
    return temp8;
}

//*****************************************************************************
// PWM[1] HIP変調１
//	HIP()
//*****************************************************************************
void HIP(void)
{
    float Vmax;  /* 最大電圧（を選ぶ） */
    float Vmin;  /* 最小電圧（を選ぶ） */

    if( Vuc0 > Vvc0 )
    {
        if(Vuc0 > Vwc0 )  /* Max=Vu */
        {
            Vmax = Vuc0;
            if( Vvc0 > Vwc0 )
            {
                Vmin = Vwc0;  /* Min=Vw */
            }
            else
            {
                Vmin = Vvc0;  /* Min=Vv */
            }
        }
        else
        {
            Vmax = Vwc0;  /* Max=Vw */
            Vmin = Vvc0;  /* Min=Vv */
        }
    }
    else
    {
        if(Vvc0 > Vwc0 )  /* Max=Vv */
        {
            Vmax = Vvc0;
            if( Vuc0 > Vwc0 )
            {
                Vmin = Vwc0;  /* Min=Vw */
            }
            else
            {
                Vmin = Vuc0;  /* Min=Vu */
            }
        }
        else
        {
            Vmax = Vwc0;  /* Max=Vw */
            Vmin = Vuc0;  /* Min=Vu */
        }

    }

    Vzero = (Vmax + Vmin)*0.5; /* MaxとMinの平均値 */
    Vuc1 = Vuc0 - Vzero;
    Vvc1 = Vvc0 - Vzero;
    Vwc1 = Vwc0 - Vzero;

}

//*****************************************************************************
// PWM[1] HIP変調２
//	HIP_m2()
//*****************************************************************************
void HIP_m2(void)
{
    float Vmax;  /* 最大電圧（を選ぶ） */
    float Vmin;  /* 最小電圧（を選ぶ） */

    if( Vuc0_2 > Vvc0_2 )
    {
        if(Vuc0_2 > Vwc0_2 )  /* Max=Vu */
        {
            Vmax = Vuc0_2;
            if( Vvc0_2 > Vwc0_2 )
            {
                Vmin = Vwc0_2;  /* Min=Vw */
            }
            else
            {
                Vmin = Vvc0_2;  /* Min=Vv */
            }
        }
        else
        {
            Vmax = Vwc0_2;  /* Max=Vw */
            Vmin = Vvc0_2;  /* Min=Vv */
        }
    }
    else
    {
        if(Vvc0_2 > Vwc0_2 )  /* Max=Vv */
        {
            Vmax = Vvc0_2;
            if( Vuc0_2 > Vwc0_2 )
            {
                Vmin = Vwc0_2;  /* Min=Vw */
            }
            else
            {
                Vmin = Vuc0_2;  /* Min=Vu */
            }
        }
        else
        {
            Vmax = Vwc0_2;  /* Max=Vw */
            Vmin = Vuc0_2;  /* Min=Vu */
        }

    }

    Vzero_2 = (Vmax + Vmin)*0.5; /* MaxとMinの平均値 */
    Vuc1_2 = Vuc0_2 - Vzero_2;
    Vvc1_2 = Vvc0_2 - Vzero_2;
    Vwc1_2 = Vwc0_2 - Vzero_2;

}

void main(void);

void H_Init(void)
{
    /********** クロックの設定 **********/
    SYSTEM.SCKCR.BIT.ICK = 0x00; // システムクロック(ICLK)       EXTAL×8 (96MHz)
    SYSTEM.SCKCR.BIT.PCK = 0x01; // 周辺モジュールクロック(PCLK) EXTAL×4 (48MHz)
    SYSTEM.MSTPCRA.BIT.MSTPA16 = 0;		// MOTOR-1 S12AD0 	@***** 未設定
    SYSTEM.MSTPCRA.BIT.MSTPA17 = 0;		// MOTOR-1 S12AD1	@***** 未設定
    SYSTEM.MSTPCRA.BIT.MSTPA23 = 0;		// MOTOR-1 AD		@***** 未設定
    SYSTEM.MSTPCRA.BIT.MSTPA24 = 0;		// MOTOR-1 S12AD	@***** 未設定
    SYSTEM.MSTPCRA.BIT.MSTPA9  = 0;		// MOTOR-1 MTU 		@***** 未設定
    // MOTOR-1
    PORTB.DDR.BIT.B4 = 0;			// MOTOR-1 HW  PB4	@***** S
    PORT1.DDR.BIT.B1 = 0;			// MOTOR-1 HV  P11	@***** S
    PORT1.DDR.BIT.B0 = 0;			// MOTOR-1 HU  P10	@***** S
    PORTB.DDR.BIT.B1 = 0;			// MOTOR-1 Z   PB1	@***** S
    PORTB.DDR.BIT.B0 = 0;			// MOTOR-1 B   PB0	@***** S
    PORTB.DDR.BIT.B3 = 0;			// MOTOR-1 A   PB3	@***** S
    PORT7.DR.BYTE  = 0x00;			// MOTOR-1 P7 PWM port	@***** S
    PORT7.DDR.BYTE = (PORT7.DDR.BYTE) | 0x7E;	// MOTOR-1 P71-p76	@***** S
    /* ポートの入力バッファの有効化　*/
    PORTB.ICR.BIT.B1 = 1;			// MOTOR-1 Z PB1 MTIOC0C@***** S
    PORTB.ICR.BIT.B0 = 1;			// MOTOR-1 B P32 MTIOC0B@***** S
    PORTB.ICR.BIT.B3 = 1;			// MOTOR-1 A P33 MTIOC0A@***** S
    IOPORT.PFCMTU.BIT.MTUS1=1;                  //0519
    // MOTOR-2
    PORTE.DDR.BIT.B3 = 0;			// MOTOR-2 HW  PE3	@***** S
    PORTE.DDR.BIT.B1 = 0;			// MOTOR-2 HV  PE1	@***** S
    PORTE.DDR.BIT.B0 = 0;			// MOTOR-2 HU  PE0	@***** S
    PORTA.DDR.BIT.B3 = 0;			// MOTOR-2 Z   PA3	@***** S
    PORTA.DDR.BIT.B4 = 0;			// MOTOR-2 B   PA4	@***** S
    PORTA.DDR.BIT.B5 = 0;			// MOTOR-2 A   PA5	@***** S
    /***************************/
    PORTB.DDR.BIT.B6 = 1;     //enable Inverter M1
    PORTE.DDR.BIT.B5 = 1;     //enable Inverter M2
    PORTB.DDR.BIT.B5 = 1;      //out 0606
    PORTB.DDR.BIT.B7 = 1;
    /************************/

    PORTE.DDR.BIT.B4 = 0;                       //PE4 SW1
    PORT9.DR.BYTE  = 0x00;			// MOTOR-2 P9 PWM port	@***** S
    PORT9.DDR.BYTE = (PORT9.DDR.BYTE) | 0x3F;	// MOTOR-2 P90-P95	@***** S
    /* ポートの入力バッファの有効化　*/
    PORTA.ICR.BIT.B3 = 1;			// MOTOR-2 Z PA3 MTIOC2A@***** S
    PORTA.ICR.BIT.B4 = 1;			// MOTOR-2 B PA4 MTIOCA4@***** S
    PORTA.ICR.BIT.B5 = 1;			// MOTOR-2 A PA5 MTIOC1A@***** S

    // 12bit ADC				// 			@***** S
    S12AD0.ADCSR.BYTE  = 0x2C;			// MOTOR-1 cycle scan mode　clock=OCLK
    // S12AD0.ADANS.WORD  = 0x3707;		// MOTOR-1 OPA_EN= AN000,AN001,AN002
    S12AD0.ADANS.WORD  = 0x3000;
    S12AD1.ADCSR.BYTE  = 0x2C;			// MOTOR-2 cycle scan mode　clock=OCLKmode
    // S12AD1.ADANS.WORD  = 0x3707;		// MOTOR-2 OPA_EN= AN100,AN101,AN102
    S12AD1.ADANS.WORD  = 0x3000;

    S12AD0.ADPG.BIT.PG000GAIN = 14;		// MOTOR-1  Gain = x5 14
    S12AD0.ADPG.BIT.PG001GAIN = 14;		// MOTOR-1  Gain = x5
    S12AD0.ADPG.BIT.PG002GAIN = 14;		// MOTOR-1  Gain = x5  変更
    S12AD1.ADPG.BIT.PG100GAIN = 14;		// MOTOR-2  Gain = x5
    S12AD1.ADPG.BIT.PG101GAIN = 14;		// MOTOR-2  Gain = x5
    S12AD1.ADPG.BIT.PG102GAIN = 14;		// MOTOR-2  Gain = x5

    S12AD.ADCMPMD0.BIT.CEN000 = 3;		// MOTOR-1 AN000 window comp for Iu
    S12AD.ADCMPMD0.BIT.CEN001 = 3;		// MOTOR-1 AN001 window comp for Iw
    S12AD.ADCMPMD0.BIT.CEN002 = 3;		// MOTOR-1 AN002 window comp for Iv 変更
    S12AD.ADCMPMD0.BIT.CEN100 = 3;		// MOTOR-2 AN100 window comp for Iu
    S12AD.ADCMPMD0.BIT.CEN101 = 3;		// MOTOR-2 AN101 window comp for Iw
    S12AD.ADCMPMD0.BIT.CEN102 = 3;		// MOTOR-2 AN102 window comp for Iv

    S12AD.ADCMPMD1.BIT.REFL   = 2;		// 基準電圧 LOW  2/8 = -5A */
    S12AD.ADCMPMD1.BIT.REFH   = 6;		// 基準電圧 HIGH 6/8 =  5A */
//  S12AD.ADCMPMD1.BIT.REFL   = 3;		// MOTOR-1 3/8 = -2.5A */
//  S12AD.ADCMPMD1.BIT.REFH   = 5;		// MOTOR-1 5/8 =  2.5A */

    S12AD.ADCMPMD1.BIT.CSEL0  = 1;		// MOTOR-1 AN000-AN002 detect after opamp    */
    S12AD.ADCMPMD1.BIT.VSELH0 = 1;		// MOTOR-1 AN000-AN002 Use REFH as reference */
    S12AD.ADCMPMD1.BIT.VSELL0 = 1;		// MOTOR-1 AN000-AN002 Use REFL as reference */
    S12AD.ADCMPMD1.BIT.CSEL1  = 1;		// MOTOR-2 AN100-AN102 detect after opamp    */
    S12AD.ADCMPMD1.BIT.VSELH1 = 1;		// MOTOR-2 AN100-AN102 Use REFH as reference */
    S12AD.ADCMPMD1.BIT.VSELL1 = 1;		// MOTOR-2 AN100-AN102 Use REFL as reference */

    S12AD.ADCMPNR0.BIT.C000NR = 8;		// MOTOR-1 AN000 detect PCLK 16times   */
    S12AD.ADCMPNR0.BIT.C001NR = 8;		// MOTOR-1 AN001
    S12AD.ADCMPNR0.BIT.C002NR = 8;		// MOTOR-1 AN002 変更
    S12AD.ADCMPNR1.BIT.C100NR = 8;		// MOTOR-2 AN100 detect PCLK 16times   */
    S12AD.ADCMPNR1.BIT.C101NR = 8;		// MOTOR-2 AN101
    S12AD.ADCMPNR1.BIT.C102NR = 8;		// MOTOR-2 AN102 変更

    S12AD.ADCMPFR.BYTE    = 0;			// 検出フラグ error clear */

    S12AD.ADCMPSEL.BIT.SEL000 = 1;		// MOTOR-1 P40 AN000
    S12AD.ADCMPSEL.BIT.SEL001 = 1;		// MOTOR-1 P41 AN001
    S12AD.ADCMPSEL.BIT.SEL002 = 1;		// MOTOR-1 P42 AN002 変更
    S12AD.ADCMPSEL.BIT.SEL100 = 1;		// MOTOR-2 P44 AN100
    S12AD.ADCMPSEL.BIT.SEL101 = 1;		// MOTOR-2 P45 AN101
    S12AD.ADCMPSEL.BIT.SEL102 = 1;		// MOTOR-2 P46 AN102
    S12AD.ADCMPSEL.BIT.IE     = 0;		// Enable CMPY
    S12AD.ADCMPSEL.BIT.POERQ  = 1;		// Enable POE */

    // 10bit ADC				// 			@***** S
    // Joy Stick AN0,AN1,AN2			// 			@***** S
    AD0.ADDPR.BIT.DPSEL = 0;			// LSB 詰め
    AD0.ADDPR.BIT.DPPRC = 0;			// 10bit

    /*************************************/
    PORTD.DDR.BIT.B0= 0;//F0
    PORTD.DDR.BIT.B1= 0;//F1
    PORTD.DDR.BIT.B2= 0;//B0
    PORTD.DDR.BIT.B3= 0;//B1
    PORTD.DDR.BIT.B5= 0;  //jiro

    /**************************************/
    DRV_sts = 0;	// MOTOR-1
    DRV_sts_2 = 0;	// MOTOR-2
}

//*******************************
// work initialize MOTOR-1
//*******************************
void work_init_m1(void)
{
    //power=1.0;
    I_ref_q_ini=0;
    DRV_sts = 0;
    s_LPF_N = 0.0;
    s_LPF_N2 = 0.0;
    s_kiASR = I_ref_q_ini;
    I_ref_ASR = I_ref_q_ini;

    S6_MODE = 1; //1
    S5_MODE=1;
    S6_MODE_p = 1;

    THdcPLL = THdc;
    s_kiPLL = 0.0;
    s_kiACR_d = 0.0;
    s_kiACR_q = 0.0;

    Nrpm_ref = 0.0;
    Nrpm_s=0;
    Nrpm=0;
    Nrpm_1=0;

    SIN0=0.0;
    COS0=0.0;

    VMODE=1;
    VMODE_z1=1;
    VMODE_z2=1;
    R_DR=0;

    YT_cnt=1;
    t_cnt=0;
    jNorm=0;
    Rot=1;
    Nref0=0;
    //inverter_stop_int();
}

//*******************************
// work initialize MOTOR-2
//*******************************
void work_init_m2(void)
{
    //power2=1.0;
    I_ref_q_ini_2=0;
    DRV_sts_2 = 0;
    s_LPF_N_2 = 0.0;
    s_LPF_N2_2 = 0.0;
    s_kiASR_2 = I_ref_q_ini_2;
    I_ref_ASR_2 = I_ref_q_ini_2;

    S6_MODE_2 = 1; //1
    THdcPLL_2 = THdc_2;
    s_kiPLL_2 = 0.0;
    s_kiACR_d_2 = 0.0;
    s_kiACR_q_2 = 0.0;

    Nrpm_ref_2 = 0.0;
    Nrpm_s_2=0;
    Nrpm_2=0;
    Nrpm_1_2=0;

    SIN0_2=0.0;
    COS0_2=0.0;

    VMODE_2=1;
    VMODE_z1_2=1;
    VMODE_z2_2=1;
    R_DR_2=0;

    YT_cnt_2=1;
    t_cnt_2=0;
    jNorm_2=0;
    Rot_2=0;
    Nref0_2=0;
    I_err_d=0;

}

void main(void)
{
    H_Init();

    //RSPI_Init();
    //ics_init((unsigned int)(&dtc_table), 6);
    //inverter_init(cPWMPRD, cDedTime);	// fs : 周期〈ns〉、dt：デッドタイム（ns）50000：521=4800：50
    //inverter_init(5000,521);		// fs : 周期〈ns〉、dt：デッドタイム（ns）50000：521=4800：50
    //inverter_init(30000,521);		// fs : 周期 (KHz)、dt：デッドタイム（ns）10000：521=4800：50
    inverter_init(15000,50);	// 16660 fs : 周期 (KHz)、dt：デッドタイム（ns）10000：521=4800：228
    inverter_start_int();


    // PORTE.DR.BIT.B5=1;
    work_init_m1();			// work initialize MOTOR-1
    work_init_m2();			// work initialize MOTOR-2


    /* RSPI0.SPCR.BIT.SPE = 1; // enable
     RSPI0.SPDR.WORD.H = 0x3A60; // データの送信
      while( 0 == RSPI0.SPSR.BIT.SPRF ); // 送信完了待ち
      RSPI0.SPDR.LONG;*/

    /*while(RSPI0.SPSR.BIT.IDLNF == 1);

     RSPI0.SPCR.BIT.SPE = 1; // enable
     RSPI0.SPDR.WORD.H = 0x3A10; // データの送信
     while( 0 == RSPI0.SPSR.BIT.SPRF ); // 送信完了待ち
     RSPI0.SPDR.LONG;*/

    while (1)
    {
        nop();
    }
}

void Period_Motor1(void)
{
    count1s = countc1;
    TC_cnt_Hole=count1s;
    // if(cflag1 == 1) {
    /*  if((count1s - count1p)>65535) {//65535
         cflag1 = 0;
          t_cnt = 1;
      }
      else {*/
    t_cnt = count1s - count1p;
    if(t_cnt>1000) {
        t_cnt=1000;

    }
    //}
    /* }
     else {
         cflag1 = 1;
     }*/
    count1p = count1s;
    Nrpm = (float)(cNrpm_P / t_cnt);	// cNrpm_P=60/cPole*96000000/cTr2; @@ 180528
}

void Period_Motor2(void)
{
    count2s = countc2;
    TC_cnt_Hole_2=count2s;
    // if(cflag1 == 1) {
    /*  if((count1s - count1p)>65535) {//65535
         cflag1 = 0;
          t_cnt = 1;
      }
      else {*/
    t_cnt_2 = count2s - count2p;
    if(t_cnt_2>1000) {
        t_cnt_2=1000;

    }
    //}
    /* }
     else {
         cflag1 = 1;
     }*/
    count2p = count2s;
    Nrpm_2 = (float)(cNrpm_P / t_cnt_2);	// cNrpm_P=60/cPole*96000000/cTr2; @@ 180528
}

//*****************************************************************************
//*****************************************************************************
// MOTOR-1 山谷割込み処理 int_carrier subroutine
//	int_carrier_m1()
//*****************************************************************************
//@****************************************************************************
void  int_carrier_m1(void)
{
//register _FLOAT tmp_vr1;
//float tmp_vr1;

    ICU.IR[0x5A].BIT.IR=0; //0601
    //TC_cnt_Ts = MTU0.TCNT;		// MTU0のカウンタ値	// @*****
    TC_cnt_Ts = countc1;


    /* ------------------ */
    /* AD変換器　スタート */
    /* ------------------ */
    S12AD0.ADCSR.BIT.ADST = 1;
    S12AD1.ADCSR.BIT.ADST = 1;
    // 10bit ADC
    AD0.ADCSR.BIT.ADST = 1;		// Joy Stick AN0,AN1,AN2	@***** S

    /* ------------ */
    /* DRV_sts 設定 */
    /* ------------ */
    SW = SW_in();/* SW1の入力 */
    if (SW==1)/* Gate OFF DRV_sts=0 */
    {
        DRV_sts = 0;
        s_LPF_N = 0.0;
        s_LPF_N2 = 0.0;
        s_kiASR = I_ref_q_ini;
        I_ref_ASR = I_ref_q_ini;

        S6_MODE = 1; //1
        THdcPLL = THdc;
        s_kiPLL = 0.0;
        s_kiACR_d = 0.0;
        s_kiACR_q = 0.0;

        Nrpm_ref = 0.0;
    }
    else
    {
        DRV_sts = 3;
    }

    /* -------------------- */
    /* 電流，電圧検出値処理 */
    /* -------------------- */

    /* ↓AD変換待ち */
    while (S12AD0.ADCSR.BIT.ADST==1) {
        nop();
    }
    while (AD0.ADCSR.BIT.ADST==1) {
        nop();    //0712
    }

    /* 過去の電圧検出値の保存 */
    // an003_1 =  an003;/* Vu過去値 */
    //an100_1 =  an100;/* Vv過去値 */
    //an101_1 =  an101;/* Vw過去値 */

    /* 電圧，電流値の取り込み */
    anX1 = AD0.ADDRA;// JoyStick X1
    anC01 =AD0.ADDRB;// JoyStick C01
    anY1 = AD0.ADDRC;// JoyStick Y1

    //an003 = S12AD0.ADDR3;		// Vu
    //an002 = S12AD0.ADDR2;    /* Vdc */
    //an003 = S12AD0.ADDR3;    /* Vu  */
    //an100 = S12AD1.ADDR0A;   /* Vv  */
    //an101 = S12AD1.ADDR1;    /* Vw  */
    an103 = S12AD1.ADDR3;    /* VR1 */
    an003 = S12AD0.ADDR3;

    /* 電流は谷割込みのみ有効 */
    if(YT_cnt == 1)  /* Y150614 */
    {
        an000 = S12AD0.ADDR0A;		// Iu
        an001 = S12AD0.ADDR2;		// Iw  @*****2
        an102 = S12AD0.ADDR1;		// Iv  @*****1
        //an001 = S12AD0.ADDR1;		// Iw
        //an102 = S12AD1.ADDR2;		/* Iv  */
    }
    else  /* 山割込みの値は不使用 */
    {
        anTMP = S12AD0.ADDR0A;		// Iu
        anTMP = S12AD0.ADDR1; 		// Iw
        anTMP = S12AD0.ADDR2;		// Iv  @*****
        //anTMP = S12AD1.ADDR2;    /* Iv  */
    }

    /* 相電流 */
    //  iu_ad  = -((float)(an000 - 2048))/(4096.0f) - offset_u;/* 3000 */
    //  iv_ad  = -((float)(an102 - 2048))/(4096.0f) - offset_v;/* 3000 */
    //  iw_ad  = -((float)(an001 - 2048))/(4096.0f) - offset_w;/* 3000 */

    iu_ad  = -((float)(an000 - 2048))/(57.344f*4) - offset_u;
    iv_ad  = -((float)(an102 - 2048))/(57.344f*4) - offset_v;
    iw_ad  = -((float)(an001 - 2048))/(57.344f*4) - offset_w;

    //  iu=(1000 * Iqc0);


    vr2_adi=((an103-fyi)/ydiv);
    Rotatei =((an003-fxi)/xdiv);

    vr2_ad += (vr2_adi- vr2_ad )*LPF_ad_1;
    Rotate += (Rotatei-Rotate)*LPF_ad_1;



    /********************距離********************/
    F0=PORTD.PORT.BIT.B0;//F0
    F1=PORTD.PORT.BIT.B1;//F1
    B0=PORTD.PORT.BIT.B2;//B0
    B1=PORTD.PORT.BIT.B3;//B1
    jiro=PORTD.PORT.BIT.B5;//jiro
#if 0
//if((Rot==0)){
    if(vr2_ad<-jth) {
        if(((F0==0)&&(F1==0))) {
            kyori=1;
        }
        else {}
        if(((F0==0)&&(F1==1))) {
            kyori=2;
        }
        else {}
        if(((F0==1)&&(F1==0))) {
            kyori=3;
        }
        else {}
        if(((F0==1)&&(F1==1))) {
            kyori=4;
        }
        else {}
    }
    else {}


    if(vr2_ad>jth) {
        if(((B0==0)&&(B1==0))) {
            kyori=1;
        }
        else {}
        if(((B0==0)&&(B1==1))) {
            kyori=2;
        }
        else {}
        if(((B0==1)&&(B1==0))) {
            kyori=3;
        }
        else {}
        if(((B0==1)&&(B1==1))) {
            kyori=4;
        }
        else {}
    }
    else {}

    PowerPPP=PowerPP;
    if(cngs==1) {
        switch (kyori)
        {
        case 1:
            PowerN = 0.45;
            break;
        case 2:
            PowerN = 0.35;
            break;
        case 3:
            PowerN = 0.25;
            break;
        case 4:
            PowerN = 0.10;
            jiro=1;
            break;
        default:
            PowerN = 0.40;
            break;
        }
        PowerPP=PowerN;
    }
    else {}

    if(PowerPPP>PowerPP) {
        PowerP=PowerP-0.01;
        cngs=0;
    }
    else {
        // PowerPPP=PowerPP;
        PowerP=PowerN;
        cngs=1;
    }
//}
//else{}
#endif
    /******************jiro*******************/

    /*   if((jiro==1)&&(cngs==0)){
    refu = 0.5;
        refv = 0.5;
        refw = 0.5;
    refu_2 = 0.5;
        refv_2 = 0.5;
        refw_2 = 0.5;
    PORTB.DR.BIT.B6=1;
    PORTE.DR.BIT.B5=1;
    }
    else{}*/
    /**********************************************/

    /****Initialize***************/

    if((vr2_ad<(jth-0.0))&&(vr2_ad>-(jth-0.0))) { //vr1_ad 0604 0.02
        if((Rotate<(jthr-0.0))&&(Rotate>-(jthr-0.0))) {   // 追加　0609 0.02

            pth=0;
            //jth=0.06;

            /*  if((Rot==1)&&(jNorm==0)) {
                  DRV_sts = 0;
                  DRV_sts_2 = 0;
              }
              else {}*/

            work_init_m1();
            PORTB.DR.BIT.B6=0;
            // Nref1=0;


            /*   kpACR =0;// 0.0665;
               kiACR =0;// 0.00165;
               kpASR =0;//0.084;
               kiASR =0;//0.0015;
              // Power1=0;
               cngs=1;
               jiro=0;
              // PowerP=0;*/
        }
        else {
            PORTB.DR.BIT.B6=1;
            Nref1=cNref1;
        }
    }
    else {
        PORTB.DR.BIT.B6=1;   //Inverter En
        Nref1=cNref1;
    }

    /***************************************************************/
//      initm1=1;
    /* ボリュームの電圧 */

    // if(fabs(s_LPF_N)>9) {
    kpACR = 0.002;//0.00015
    kiACR = 0.0000006;//0.0000005
    kpASR = 0.08;//0.0008 Speed
    kiASR = 0.002;// 0.00001;
    LPF_ad_1=0.025;//0.025
    Power1=0.083333;//PowerP;
    kpPLL = 40.0;//10
    kiPLL =0.02;//0.002

    /*  }
      else {
          kpACR=0.0015;//0.55;
          kiACR=0.000005;//0.0001;
          kpASR =0.08;// kpASR_2+0.01;//Speed
          kiASR =0.002;// kiASR_2+0.002;
          LPF_ad_1=0.03;//0.001
          Power1=0.083333;//Power1+0.00011;
      }*/


    /********************************************************************/
    /*  if((vr2_ad<(jth+pth))&&(vr2_ad>-(jth+pth))){//&&(Rot==1)){
     if((Rotate>jthr)){//||(Rotate<-jthr)){
       jNorm=0;
       Rot=1;
      // pth=0.2;
      // Power1=0.02;
      // Power2=0.02;
        }
        else{jNorm=1;}

      }
      else{jNorm=1;}

       if((vr2_ad<(jth+pth))&&(vr2_ad>-(jth+pth))){//&&(Rot==1)){
     if((Rotate<-jthr)){
       jNorm=0;
       Rot=1;
      // pth=0.2;
      // Power1=0.02;
      // Power2=0.02;
        }
        else{jNorm=1;}

      }
      else{jNorm=1;}

    if((Rotate>jthr)&&(Rot==1)){
         vr2_ad = -Rotate;
         vr1_ad =  vr2_ad/Rotp;

      }
      else{}

      if((Rotate<-jthr)&&(Rot==1)){
         vr2_ad = -Rotate;
         vr1_ad=  vr2_ad/Rotp;

      }
      else{}*/

    if((Rotate<=jthx)&&(Rotate>=-jthx)) {
        Lp=1.0;
    }
    else {}

    if(Rotate>jthx) {
        Lp=1.0;
    }
    else {}

    if(Rotate<-jthx) {
        Lp=0.0;
    }
    else {}


    // if(jNorm==1){   //hidari
    //  Rot=0;
    //  vr1_ad=vr2_ad*(0.5 + Rotate);
    
/////////////////////////////////////////////////////////////////////
//  %%%%%                %%%%%                               %%    //
//  %    %              %     %              %                %    //
//  %    % %  % %%%%    %        %%%  %%%%  %%%  % %%   %%%   %    //
//  %%%%%  %  % %   %   %       %   % %   %  %   %%  % %   %  %    //
//  %  %   %  % %   %   %       %   % %   %  %   %     %   %  %    //
//  %   %  %  % %   %   %     % %   % %   %  %   %     %   %  %    //
//  %    %  %%  %   %    %%%%%   %%%  %   %   %% %      %%%    %%  //
/////////////////////////////////////////////////////////////////////
/*
【注意】Run Control部はMotor1のみで実行する事
        Joy stickに関連する部分も同様です。
        
    void Run_Control(void) {
        // MOTORに関係しない共通部分
    }

    void MOTOR_DRIVE(_UBYTE motor_num) {
        register _UBYTE idx;
        idx = (motor_num == 1)? 0 : 1;
        ...
        mp[idx].Nrpm = ....  <-- MOTOR1
        ...
        ...
    }
   
    void int_carrier_m1(void) {
        Run_Control();
        MOTOR_DRIVE(1);
    }
   
    void int_carrier_m2(void) {
        MOTOR_DRIVE(2);
    }   
*/

    // Prepare tmp_vr1 as differentiater
#if 1
    tmp_vr1 = vr1_ad;
    
    if(Run == 0) {
        //////////////////////
        // Run == 0 := Stop
        //
        jth=0.06;

        if(fabs(vr2_ad) > jth) {
            Run = 1;

            if(vr2_ad > 0) {
                R_DR = 1;       // CCW
                tmp_vr1 = vr2_ad - jth;
                //tmp_vr1 = (tmp_vr1 < 0.0)? 0.0 : tmp_vr1;
            }
            else if(vr2_ad < 0) {//vr1
                R_DR = 0;       // CW
                tmp_vr1 = vr2_ad + jth;
                //tmp_vr1 = (tmp_vr1 > 0.0)? 0.0 : tmp_vr1;
            }
            else {}

        }
        else {}
    }
    else {
        //////////////////////////
        //  Run == 1 :: Running
        //
        jth = 0.03;
        
        if(fabs(vr2_ad) < jth) {
            Run = 0;
            tmp_vr1 = 0.0;
        }
    }
    
    ////////////////////////
    // vr1_ad post process
    //
    if(vr1_ad > 0.0) { //vr1_ad
        if((vr1_ad - tmp_vr1) > dS_dt) {
            vr1_ad -= dS_dt;//
        }
    }
    else if(vr1_ad < 0.0) { //vr1_ad
        if((tmp_vr1 - vr1_ad) > dS_dt) {
            vr1_ad += dS_dt;//
        }
    }
    else {
        vr1_ad = tmp_vr1;
        // vr1_ad = vr2_ad;
    }
    
#endif
    vr1_ad = vr2_ad;
    //////////////////////////////
    //  End of Run_Control      //
    //////////////////////////////

    /*  if(vr2_ad>jth){
      vr1_ad=vr2_ad-jth;
      }
      else{ vr1_ad=0;}

      if(vr2_ad<-jth){
      vr1_ad=vr2_ad+jth;
      }
      else{ vr1_ad=0;}*/

    //vr1_ad=(vr2_ad-Rotate)*Lp;//vr2_ad + Rotate;
    //      }
    //   else{}


    /* if((vr2_ad>jth)&&(jNorm==1)){  // 1st wheel Back

            vr1_ad=(vr2_ad)/dp1;
    	Rot=0;
    	//jth=0.03;
         if(Rotate>jthx){  //Right Back

    	  vr1_ad=vr2_ad/dp1+(Rotate)/dpr1;
         }
         else{}

         if(Rotate<-jthx){ //Left Back

    	   vr1_ad=vr2_ad/dp1+(Rotate)/dpr1;

         }
         else{}

     }
     else{ }//0612

     if((vr2_ad<-jth)&&(jNorm==1)){ // 1st wheel Forward hidari
    	   Rot=0;
         vr1_ad=(vr2_ad)/dp1;

      if(Rotate>jthx){  //Rigtht Forward
    	vr1_ad=vr2_ad/dp1-(Rotate)/dpr1;
          }
      else{}

     if(Rotate<-jthx){  //Left Forward
    	  vr1_ad=vr2_ad/dp1-(Rotate)/dpr1;

         }
      else{}

        }
     else{}*/

    /***********************************************************************/
    /* if(power<1.5)
     {
     power=power+0.001;//+0.001;//0.0005
     }*/

    /*if(vr1_ad>=0.35){
    vr1_ad=0.35;
    }
    else{}
    if(vr1_ad<=-0.35){
    vr1_ad=-0.35;
    }
    else{}*/

    /*****************************************************************************/
    /* ****************** */
    /* Iuvw -> dq座標変換 */
    /* ****************** */
    /* 電流は谷割込みのみ有効 */
    if(YT_cnt == 1)  /*  */
    {
        /* UVW -> αβ */
        Iac0 = 0.816496580928*(iu_ad - 0.5*(iv_ad + iw_ad));
        /* ↑Iα=sqrt(2/3)*{Iu-(Iv+Iw)/2} */
        Ibc0 = 0.7071067811866*(iv_ad - iw_ad);
        /* ↑Iβ=sqrt(1/2)*(Iv-Iw) */

        if((PLL_ON == 1)&&(S6_MODE != 1))
        {
            SIN0 = sin(THdcPLL);/**/
            COS0 = cos(THdcPLL);/**/
        }
        else
        {
            SIN0 = sin(THdc);/**/
            COS0 = cos(THdc);/**/
        }

        /* αβ -> dq */
        Idc0 = Iac0*COS0 +Ibc0*SIN0;  //  +
        Iqc0 =  -Iac0*SIN0 + Ibc0*COS0; //  -
    }
    else {}

    iu=(int)(1000 * Iqc0);//2018
    s_LPF_id0 += (Idc0 - s_LPF_id0)*k_LPF_id0;
    s_LPF_iq0 += (Iqc0 - s_LPF_iq0)*k_LPF_iq0;


    /* *********************************************** */
    /* [ 1 ] 速度検出↓ */
    /* *********************************************** */
    /* MTU0.TGRDにキャプチャ発生 */
    /*MTI0.TGRAにキャプチャ発生 */

#if  1
    if(MTU0.TSR.BIT.TGFA == 1)                   //0606 D
    {
        MTU0.TSR.BIT.TGFA = 0;			// @@ 180528 0606D
        TC_FLG = 1;
        Period_Motor1();
    }
#else
    if(MTU0.TSR.BIT.TGFA == 1)                   //0606 D
    {
        MTU0.TSR.BIT.TGFA = 0;			// @@ 180528 0606D

        TC_cnt_3A = MTU0.TGRA;                 // @@ 180526 0606 D
        //TC_cnt_3A = MTU3.TGRA;		// 0526
        //MTU3.TSR.BIT.TGFD = 0;
        TC_FLG = 1;  /* キャプチャ発生フラグ */
        TC_cnt_Hole = TC_cnt_3A;/**/
        t_cnt = TC_cnt_3A - TC_cnt_3A_1;


        if(t_cnt>=cNrpm_P/kdiv) {
            t_cnt=cNrpm_P;
        }
        else {}
        // Nrpm = (cNrpm_P/2/t_cnt*2)
        // cNrpm_P = 60 * cIMCLK_FRQ * 1000000. / cTr2 * 1000 / cPole); cPole=8;cTr2=64;
        Nrpm = (float)(cNrpm_P / t_cnt);	// cNrpm_P=60/cPole*96000000/cTr2; @@ 180528
        //Nrpm = (float)(9000000 / t_cnt);	// P=10	60/10*96000000/64 @*****
        //Nrpm = (float)(11250000 / t_cnt);	// P=8	60/8*96000000/64 @*****
        if( ((Nrpm-Nrpm_1)<EMR_DRPM) && ((Nrpm-Nrpm_1)>(-EMR_DRPM)) )
        {   /* 速度異常 */
            Nrpm_1 = Nrpm;
        }
        else
        {
            Nrpm = Nrpm_1;
        }

        TC_cnt_3A_1 = TC_cnt_3A;
    }
    else {}

#endif

    /* MTU0.TGRCにキャプチャ発生 */
    /* MTU0.TGRDにキャプチャ発生 */
#if 1
    if(MTU0.TSR.BIT.TGFD == 1)			// @@ 180526 0606 C
    {
        MTU0.TSR.BIT.TGFD = 0;			// @@ 180526 0606 C
        TC_FLG = 1;
        Period_Motor1();

    }
#else
    if(MTU0.TSR.BIT.TGFD == 1)			// @@ 180526 0606 C
    {
        TC_cnt_3C = MTU0.TGRD;			// @@ 180526 0606 C
        MTU0.TSR.BIT.TGFD = 0;			// @@ 180526 0606 C
        //TC_cnt_3C = MTU3.TGRC;
        //MTU3.TSR.BIT.TGFC = 0;

        TC_FLG = 1;  /* キャプチャ発生フラグ */
        TC_cnt_Hole = TC_cnt_3C;/**/

        t_cnt = TC_cnt_3C - TC_cnt_3C_1;
        if(t_cnt<1) {
            t_cnt=1;
        }
        else {}
        if(t_cnt>=cNrpm_P/kdiv) {
            t_cnt=cNrpm_P;
        }
        else {}
        // Nrpm = (cNrpm_P/2/t_cnt*2)
        // cNrpm_P = 60 * cIMCLK_FRQ * 1000000. / cTr2 * 1000 / cPole); cPole=8;cTr2=64;
        Nrpm = (float)(cNrpm_P / t_cnt);	// cNrpm_P=60/cPole*96000000/cTr2; @@ 180528
        //Nrpm = (float)(9000000 / t_cnt);	// P=10	60/10*96000000/64 @*****
        //Nrpm = (float)(11250000 / t_cnt);	// P=8	60/8*96000000/64 @*****

        if( ((Nrpm-Nrpm_1)<EMR_DRPM) && ((Nrpm-Nrpm_1)>(-EMR_DRPM)) )
        {   /* 速度異常 */
            Nrpm_1 = Nrpm;
        }
        else
        {
            Nrpm = Nrpm_1;
        }

        TC_cnt_3C_1 = TC_cnt_3C;
    }
    else {}
#endif
    /* MTU0.TGRAにキャプチャ発生 */
    /* MTU0.TGRCにキャプチャ発生 */
#if 1
    if(MTU0.TSR.BIT.TGFC == 1)			// @@ 180526 0606 A
    {
        MTU0.TSR.BIT.TGFC = 0;			// @@ 180526 0606 A
        TC_FLG = 1;
        Period_Motor1();
    }
#else
    if(MTU0.TSR.BIT.TGFC == 1)			// @@ 180526 0606 A
    {
        TC_cnt_1A = MTU0.TGRC;			// @@ 180526 0606 A
        MTU0.TSR.BIT.TGFC = 0;			// @@ 180526 0606 A

        TC_FLG = 1;  /* キャプチャ発生フラグ */
        TC_cnt_Hole = TC_cnt_1A;/**/

        t_cnt = TC_cnt_1A - TC_cnt_1A_1;
        //t_cnt = TC_cnt_1A_1 - TC_cnt_1A;
        if(t_cnt<1) {
            t_cnt=1;
        }
        else {}
        if(t_cnt>=cNrpm_P/kdiv) {
            t_cnt=cNrpm_P;
        }
        else {}

        // Nrpm = (cNrpm_P/2/t_cnt*2)
        // cNrpm_P = 60 * cNrpm_PcIMCLK_FRQ * 1000000. / cTr2 * 1000 / cPole); cPole=8;cTr2=64;
        Nrpm = (float)(cNrpm_P / t_cnt);	// cNrpm_P=60/cPole*96000000/cTr2; @@ 180528
        //Nrpm = (float)(9000000 / t_cnt);	// P=10	60/10*96000000/64 @*****
        //Nrpm = (float)(11250000 / t_cnt);	// P=8	60/8*96000000/64 @*****
        //kaiten=(float)(cNrpm_P / t_cnt);

        if( ((Nrpm-Nrpm_1)<EMR_DRPM) && ((Nrpm-Nrpm_1)>(-EMR_DRPM)) )
        {   /* 速度異常 */
            Nrpm_1 = Nrpm;
        }
        else
        {
            Nrpm = Nrpm_1;
        }

        TC_cnt_1A_1 = TC_cnt_1A;
    }
    else {}
#endif
    /* 正転，逆転のチェック */
    if(R_DR==1)/* 正転 */
    {
        Nrpm_s = Nrpm; //+ 1202
    }
    else/* 逆転 */
    {
        Nrpm_s = -Nrpm;  // aki 1202 -

    }
    /* 速度フィルタ */
#if 0
    s_LPF_N= Nrpm_s;
    s_LPF_N2= Nrpm_s;
#else

    s_LPF_N += (Nrpm_s - s_LPF_N )*k_LPF_N;
    s_LPF_N2 += (Nrpm_s - s_LPF_N2 )*k_LPF_N2;
    // kaiten +=(Nrpm_s - s_LPF_N )*k_LPF_N;
#endif
// f[Hz]= Nrpm*cF_P; 計算定数 cF_P=cPole/60/2; cPole=8;
    Fe1 = s_LPF_N*cF_P;		// cF_P = cPole/120;		// @@ 180528
//Fe1 = s_LPF_N2*0.016666666667;	// f[Hz]= Nrpm/60*10[pole]	// @*****
//Fe1 = s_LPF_N2*0.06666666667;	// f[Hz]= Nrpm/60/2*8[pole]	// @*****
    We1 = TWOPI*Fe1;  /* ω1 = 2π・f1 */
    dTHdc = Ts0*We1;  /* θs = ω1・Ts */

    /* Hole IC PLL  */
    if(	TC_FLG == 1)  /* キャプチャ発生時の速度領域 */
    {
#if 1
        if(s_LPF_N > NRPM_MIN)  /* 正転 */
        {
            S6_MODE_p = 2;/* 0: -sin, 1:6step, 2:+sin */
            S5_MODE=S6_MODE_p;
        }
        else
        {
            if(s_LPF_N < (-NRPM_MIN))  /* 逆転 */
            {
                S6_MODE_p = 0;/* 0: -sin, 1:6step, 2:+sin  aki 0 */
                S5_MODE=S6_MODE_p;
            }
            else  /* 零付近ウロウロ */
            {
                S6_MODE = 1;/* 0: -sin, 1:6step, 2:+sin */

                //I_ref_q_ini=Start;//0603
            }
        }
#endif

        //if(vr1_ad>0.05)
        //{
        // サンプル開始までのずれ角計算定数 cdt_P=cTr2/cIMCLK_FRQ/1000000; cTr2=64; IMCLK_FRQ=96[MHz]
        // cdt_P = cTr2 / cIMCLK_FRQ / 1000000.= 64/96000000[Hz]
        dTH_hole = cdt_P*((float)( TC_cnt_Ts - TC_cnt_Hole))*We1;			// @@ 180528
        //dTH_hole = 0.0000006*((float)( TC_cnt_Ts - TC_cnt_Hole))*We1;		// @*****
        // ↑サンプル開始までのずれ角 dt=1/1500000  (1500000=96MHz/64)
        // dTH_hole = 0.0000026666667*((float)( TC_cnt_Ts - TC_cnt_Hole))*We1;	// @*****
        // ↑サンプル開始までのずれ角 dt=1/375000  (375000=96MHz/256)
        //}
        //else
        //{
        // サンプル開始までのずれ角計算定数 cdt_P=cTr2/cIMCLK_FRQ/1000000; cTr2=64; IMCLK_FRQ=96[MHz]
        // cdt_P = cTr2 / cIMCLK_FRQ / 1000000.= 64/96000000[Hz]=0.00000007
        //dTH_hole = cdt_P*((float)( TC_cnt_Ts - TC_cnt_Hole))*We1;			// @@ 180528
        //dTH_hole = 0.0000006*((float)( TC_cnt_Ts - TC_cnt_Hole))*We1;		// @*****
        // ↑サンプル開始までのずれ角 dt=1/1500000  (1500000=96MHz/64)
        //dTH_hole = 0.0000026666667*((float)( TC_cnt_Ts - TC_cnt_Hole))*We1;	// @*****
        // ↑サンプル開始までのずれ角 dt=1/1500000  (1500000=96MHz/256)

        //}



        if((dTH_hole > DEG030N)||(dTH_hole < (-DEG030N)))
        {
            dTH_hole = 0.0;
        }
        else {}
    }
    else
    {
        dTH_hole = 0.0;
    }




    /*a_LPF_N=fabs(s_LPF_N);

    if(a_LPF_N<40){
    		kpPLL = 40.0;	//12.0
                	kiPLL =0.035; //0.0025

    }
    else{}
    if((a_LPF_N>=40)&&(a_LPF_N<60)){
    		kpPLL = 50.0;
                	kiPLL =0.065;

    }
    else{}
    if((a_LPF_N>=60)&&(a_LPF_N<90)){
    		kpPLL = 60.0;
                	kiPLL =0.070;

    }
    else{}
    if((a_LPF_N>=90)){
    		kpPLL = 70.0;
                	kiPLL =0.075;

    }
    else{}*/

    V_MODE = UVW_in(); /* Hole IC信号の状態 */

#if 0
    switch (HUVW)
    {
    case 1:
        V_MODE = 2;
        break;
    case 2:
        V_MODE = 4;
        break;
    case 3:
        V_MODE = 3;
        break;
    case 4:
        V_MODE = 6;
        break;
    case 5:
        V_MODE = 1;
        break;
    case 6:
        V_MODE = 5;
        break;
    default:
        V_MODE = 1;
        break;
    }
#endif

    if((S5_MODE == 2)&&(TC_FLG == 1))//S6_MODE
    {
        switch (V_MODE)
        {
        case 1:
            TH_hole = DEG210N;  /* θhole[rad] 210 */
            break;
        case 2:
            TH_hole = DEG270N;  /* θhole[rad] 270 */
            break;
        case 3:
            TH_hole = DEG330N;  /* θhole[rad] 330 */
            break;
        case 4:
            TH_hole = DEG030N;  /* θhole[rad] 30 */
            break;
        case 5:
            TH_hole = DEG090N;  /* θhole[rad] 90 */
            break;
        case 6:
            TH_hole = DEG150N;  /* θhole[rad] 150 */
            break;
        default:
            TH_hole = DEG210N;  /* θhole[rad] 210 */
            break;
        }
        THdc = TH_hole + dTH_hole;
        TH_sin_on = 1;

        THdc_err = THdc - THdcPLL;
        while(THdc_err > ONEPI)  /* 「-π < θdc < π」に制限 */
        {
            THdc_err -= TWOPI;
        }
        while(THdc_err < (-ONEPI))  /* 「-π < θdc < π」に制限 */
        {
            THdc_err += TWOPI;
        }/**/
    }
    else {}

    if((S5_MODE == 0)&&(TC_FLG == 1))////S6_MODE
    {
        switch (V_MODE)
        {
        case 1:
            TH_hole = DEG270N;  /* θhole[rad] 270 */
            break;
        case 2:
            TH_hole = DEG330N;  /* θhole[rad] 330 */
            break;
        case 3:
            TH_hole = DEG030N;  /* θhole[rad] 30 */
            break;
        case 4:
            TH_hole = DEG090N;  /* θhole[rad] 90 */
            break;
        case 5:
            TH_hole = DEG150N;  /* θhole[rad] 150 */
            break;
        case 6:
            TH_hole = DEG210N;  /* θhole[rad] 210 */
            break;
        default:
            TH_hole = DEG270N;  /* θhole[rad] 270 */
            break;

        }
        THdc = TH_hole + dTH_hole;//aki +
        TH_sin_on = 1;

        THdc_err = THdc - THdcPLL; //aki -
        while(THdc_err >( ONEPI))  /* 「-π < θdc < π」に制限 */
        {
            THdc_err -= TWOPI;  //aki -
        }
        while(THdc_err < (-ONEPI))  /* 「-π < θdc < π」に制限 */
        {
            THdc_err += TWOPI;  //aki+
        }/**/

    }
    else {}

    if(S6_MODE == 1)
    {
        //  if(vr2_ad>=jth) {
        switch (V_MODE)
        {
        case 1:
            TH_hole = DEG240N;  //240
            break;
        case 2:
            TH_hole = DEG300N;  //300
            break;
        case 3:
            TH_hole = 0.0;//   //0.0
           // S6_MODE=S5_MODE;
            break;
        case 4:
            TH_hole = DEG060N; //60
            S6_MODE=S5_MODE;
            break;
        case 5:
            TH_hole = DEG120N;  //120
            break;
        case 6:
            TH_hole = DEG180N;  //180
            break;
        default:
            TH_hole =DEG240N;  //240
            break;
        }
        // }
        // else {}

        /* if(vr2_ad<-jth) {

             switch (V_MODE)
             {
             case 1:
                 TH_hole = DEG240N;  //180
                 break;
             case 2:
                 TH_hole = DEG300N;  //240
        //S6_MODE=S5_MODE;
                 break;
             case 3:
                 TH_hole = 0.0;     //300
        //S6_MODE=S5_MODE;
                 break;
             case 4:
                 TH_hole = DEG060N; //0

                 break;
             case 5:
                 TH_hole = DEG120N;//60

                 break;
             case 6:
                 TH_hole = DEG180N;  //120
        S6_MODE=S5_MODE;
                 break;
             default:
                 TH_hole =DEG240N;  //120
                 break;
             }
         }
         else {}*/

        //}
        THdc = TH_hole;//aki +
        TH_sin_on = 0;

        THdcPLL = THdc;/*aki+*/
        THdc_err = 0.0;/**/
        s_kiPLL = 0.0;/**/
        //Start=St6; //aki 0519
    }
    else {/* Start=StV;*/} //aki 0519

    TC_FLG = 0;


    if(TH_sin_on == 1)
    {
        THdc = THdc + dTHdc;/* 次回のdq変換位相 */
    }
    else {}

    while(THdc > TWOPI)  /* 「0 < θdc < 2π」に制限 */
    {
        THdc -= TWOPI;
    }
    while(THdc < 0.0)
    {
        THdc += TWOPI;
    }

    /************/
    /*  PLL制御 */
    /* ******** */

    s_kiPLL += kiPLL*THdc_err;
    W1PLL = s_kiPLL + kpPLL*THdc_err;
    THdcPLL = THdcPLL +  W1PLL*Ts0;
    while(THdcPLL > TWOPI)  /* 「0 < θdc < 2π」に制限 */
    {
        THdcPLL -= TWOPI;
    }
    /* while(THdc < 0.0)
     {
    THdcPLL += TWOPI;
     } */
    while(THdcPLL < 0.0) //aki
    {
        THdcPLL += TWOPI;
    }

    /* モードから位相がはみ出さないように処理 */
    switch(V_MODE)
    {
    case 1:
        if((DEG330N > THdc )&&( THdc > DEG270N )) {
            THdc = DEG270N;
        }
        else
        {
            if(( DEG150N < THdc )&&( THdc < DEG210N )) {
                THdc = DEG210N;
            }
            else {}
        }
        break;
    case 2:
        if(THdc > DEG330N ) {
            THdc = DEG330N;
        }
        else
        {
            if((DEG210N < THdc )&&( THdc < DEG270N )) {
                THdc = DEG270N;
            }
            else {}
        }
        break;
    case 3:
        if(( DEG090N > THdc )&&( THdc  > DEG030N )) {
            THdc = DEG030N;
        }
        else
        {
            if((DEG270N < THdc )&&( THdc < DEG330N )) {
                THdc = DEG330N;
            }
            else {}
        }
        break;
    case 4:
        if((DEG150N > THdc )&&( THdc > DEG090N )) {
            THdc = DEG090N;
        }
        else
        {
            if(( 0 < THdc )&&( THdc < DEG030N )) {
                THdc = DEG030N;
            }
            else {}
        }
        break;
    case 5:
        if((DEG210N > THdc )&&( THdc > DEG150N )) {
            THdc = DEG150N;
        }
        else
        {
            if(( DEG030N < THdc )&&( THdc < DEG090N )) {
                THdc = DEG090N;
            }
            else {}
        }
        break;
    case 6:
        if((DEG270N > THdc )&&( THdc > DEG210N )) {
            THdc = DEG210N;
        }
        else
        {
            if((DEG090N < THdc )&&( THdc < DEG150N )) {
                THdc = DEG150N;
            }
            else {}
        }
        break;
    default:
        break;
    }


    /* ↑ここまで（速度・位相計算） */

    switch(DRV_sts)
    {
    case 0:
        s_LPF_N = 0.0;
        s_LPF_N2 = 0.0;
        break;
    case 1:
        s_LPF_N = 0.0;
        s_LPF_N2 = 0.0;
        break;
    case 2:
        break;
    case 3:
#if 0
        // jth=0.03; //20181208
        if(vr1_ad<0) {
            R_DR=1;
        }
        else {
            R_DR=0;
        }
#endif
        break;
    default:
        s_LPF_N = 0.0;
        s_LPF_N2 = 0.0;
        break;
    }

    if (DRV_sts == 0)
    {
        Nrpm = 0.0;
        Nrpm_1 = 0.0;
    }
    else {}



    /* *********************************************** */
    /* [ 2 ] 速度制御 ↓ */
    /* *********************************************** */

    /* 回転数指令，誤差信号の処理 */
    switch(DRV_sts)
    {
    case 0:
        Nrpm_ref = 0.0;
        Nrpm_ref0 = 0.0;
        Nerr = 0.0;
        break;
    case 3:
        /*	Nrpm_ref = Nref1*vr1_ad;
        	if(Nrpm_ref<Nref0)
        	{
          		Nrpm_ref = Nref0;
        	}
        	else{}
        */

        Nrpm_ref0 = fabs(Nref1 * vr1_ad); //aki  Nref1 MAX Speed -
        //Nrpm_ref0 = Nref1*-0.5;
        // if(Nrpm_ref0>0) {
        // Nrpm_ref0 = Nref1*(vr1_ad-0.05);
        if(Nref0 > Nrpm_ref0)
        {
            Nref0 -= dN_HI_N; //aki -
            if(Nref0 < Nrpm_ref0)
            {
                Nref0 = Nrpm_ref0;
            }
            else {}
        }
        else {}

        if(Nref0 < Nrpm_ref0)
        {
            Nref0 += dN_HI_P;  //aki +
            if(Nref0 > Nrpm_ref0)
            {
                Nref0 = Nrpm_ref0;
            }
            else {}
        }
        else {}
        if(Nref0<N_LOW_MAX)
        {
            Nref0 = N_LOW_MAX;
        }
        else {}
        Nrpm_ref = Nref0;
        if(R_DR==1) {
            Nerr = Nrpm_ref- Nrpm_s;//- 12 02 2018
        }
        else {
            Nerr = Nrpm_ref+ Nrpm_s;
        }

        if(Nerr>=50) {
            Nerr=50;
        }
        else {}
        if(Nerr<-50) {
            Nerr=-50;
        }
        else {}

        // }
        /*  else {}
          if(Nrpm_ref0<0) {
              // Nrpm_ref0 = Nref1*(vr1_ad+0.05);
              if(Nref0 < Nrpm_ref0)//Nrpm_ref0 wa minus
              {
                  Nref0 += dN_HI_N; //aki +
                  if(Nref0 > Nrpm_ref0)
                  {
                      Nref0 = Nrpm_ref0;
                  }
                  else {}
              }
              else {}

              if(Nref0 > Nrpm_ref0)
              {
                  Nref0 -= dN_HI_P;  //aki +
                  if(Nref0 < Nrpm_ref0)
                  {
                      Nref0 = Nrpm_ref0;
                  }
                  else {}
              }
              else {}

              if(Nref0>-N_LOW_MAX)
              {
                  Nref0 =-N_LOW_MAX;//*aki
              }
              else {}
              Nrpm_ref = Nref0;

              Nerr = -Nrpm_ref + Nrpm_s;//センサ付 aki +


          }
          else {}*/
        /*#define ErrMax 1000
                if(Nerr < -ErrMax) {
                    Nerr = -ErrMax;
                }
                else {}

                if(Nerr > ErrMax) {
                    Nerr = ErrMax;
                }*/
        // Nerr=-Nerr;

        break;
    default:
        break;
    }

    /* ----------- */
    /* ASRのPI制御 */
    /* ----------- */
    s_kiASR += kiASR*Nerr;
    if(s_kiASR >I1_LIM )//I1_LIM
    {
        s_kiASR = I1_LIM;
    }
    else
    {
        if(s_kiASR < -I1_LIM)
        {
            s_kiASR = -I1_LIM;
        } else {}


    }

    I_ref_ASR = s_kiASR + kpASR*Nerr;

    if(I_ref_ASR > I1_LIM)//I1_LIM
    {
        I_ref_ASR = I1_LIM;//I1_LIM;
    }
    else
    {
        if(I_ref_ASR < (-I1_LIM))
        {
            I_ref_ASR = -I1_LIM;
        } else {}

    }

    /* ASRの初期値 */
    if(DRV_sts != 3)
    {
        s_kiASR = I_ref_q_ini;
        I_ref_ASR = I_ref_q_ini;
    }
    else {}


    /* *********************************************** */
    /* [ 3 ] 電流制御 ↓ */
    /* *********************************************** */

    /* 電流指令 */
    switch(DRV_sts)
    {
    case 0: /* 待機状態 */
        I_ref_q = 0; 			/* q軸電流指令 */
        I_err_q = 0;			/* q軸電流偏差 */
        s_kiACR_q = 0.0;		/* q軸ACRの積分器クリア */
        s_kiASR = 0.0;			/* ASRの積分器クリア */
        break;
    case 3: /* 駆動開始 */
        I_ref_d = 0.0;			/* d軸電流指令 */
        I_err_d = I_ref_d - Idc0;	/* d軸電流偏差 */
        I_ref_q = I_ref_ASR;		/* q軸電流指令 */
        I_err_q = I_ref_q - Iqc0;	/* q軸電流偏差 */
        break;
    default:
        I_ref_q = 0;
        I_err_q = 0;
        s_kiACR_q = 0.0;
        s_kiASR = 0.0;
        break;
    }

    /* ----------- */
    /* ACRのPI制御 */
    /* ----------- */

    /* d軸ACR */
    s_kiACR_d += kiACR*I_err_d; /* d軸積分処理 */
    if(s_kiACR_d > V1_LIM)
    {
        s_kiACR_d = V1_LIM;
    }
    else
    {
        if(s_kiACR_d < (-V1_LIM))
        {
            s_kiACR_d = -V1_LIM;
        } else {}
    }

    Vdc0 = s_kiACR_d + kpACR*I_err_d; /* d軸電圧指令Vd */

    if(Vdc0 > V1_LIM)
    {
        Vdc0 = V1_LIM;
    }
    else
    {
        if(Vdc0 < (-V1_LIM))
        {
            Vdc0 = -V1_LIM;
        } else {}
    }



    /* q軸ACR */
    s_kiACR_q += kiACR*I_err_q;  /* q軸積分処理 */
    if(s_kiACR_q > V1_LIM)
    {
        s_kiACR_q = V1_LIM;
    }
    else
    {
        if(s_kiACR_q < (-V1_LIM))
        {
            s_kiACR_q = -V1_LIM;
        } else {}
    }

    Vqc0 = s_kiACR_q + kpACR*I_err_q; /* q軸電圧指令Vq */

    if(Vqc0 > V1_LIM)
    {
        Vqc0 = V1_LIM;
    }
    else
    {
        if(Vqc0 < (-V1_LIM))
        {
            Vqc0 = -V1_LIM;
        } else {}
    }

    /* 電流フィルタ */
    s_LPF_i += (Iqc0 - s_LPF_i )*k_LPF_i;


    /* *********************************************** */
    /* [ 4 ] PWMの設定 */
    /* *********************************************** */

    /* mのリミッタ */
    if      (m >  m1_LIM) {
        m =  m1_LIM;
    }
    else if (m < (-m1_LIM)) {
        m = -m1_LIM;
    }
    else               { /* no code */ }

    if (DRV_sts == 0) {
        m = 0.0;
    }
    else       { /* no code */ }

    /* --------- */
    /* LEDの設定 */
    /* --------- */

    /* ホールIC信号 */
//LED2_set(U_in()); /**/
//LED3_set(V_in()); /**/
//LED4_set(W_in()); /**/

    /* 過去モードの保存 */
    VMODE_z2 = VMODE_z1;/* 前回値保存 */
//VMODE_z1 = VMODE;/* 前回値保存 */


    /* ------------ */
    /* モードの更新 */
    /* ------------ */

    UVW = UVW_in(); /* センサ付・ホールIC信号 */

    switch(DRV_sts)
    {
    case 0:
        VMODE = 1;
        break;
    case 1:
        VMODE = 1;
        break;
    case 2:

    case 3: /* ホールIC信号→VMODEのデコード　*/
        switch (UVW)
        {
        case 1:
            VMODE_z1 = 2;
            break;
        case 2:
            VMODE_z1 = 4;
            break;
        case 3:
            VMODE_z1 = 3;
            break;
        case 4:
            VMODE_z1 = 6;
            break;
        case 5:
            VMODE_z1 = 1;
            break;
        case 6:
            VMODE_z1 = 5;
            break;
        default:
            VMODE_z1 = 1;
            break;
        }
        break;
    default:
        break;
    }

    /* ---------------------- */
    /* 回転方向 */
    /* R_DR -> 1:正転，0:逆転 */
    /* ---------------------- */
   /*  if(VMODE_z2 == VMODE_z1) {}
     else
     {
         if(VMODE_z2 < VMODE_z1)
         {
             if((VMODE_z2==1)&&(VMODE_z1==6)) {
                 R_DR=0;   // R_DR=0 1
             }
             else {
                 R_DR=1;
             }
         }
         else
         {
             if((VMODE_z2==6)&&(VMODE_z1==1)) {
                 R_DR=1;   //R_DR=1 0
             }
             else {
                 R_DR=0;
             }
         }
     }*/

    /* **************** */
    /*     位相更新     */
    /* **************** */
    We1 = TWOPI*Fe1;  /* ω1 = 2π・f1 */
    dTHdc = Ts0*We1;  /* θs = ω1・Ts aki +*/

    if((PLL_ON == 1)&&(S6_MODE != 1))
    {
        THdcV = THdcPLL + dTHdc*0.5/* 今回設定するdq逆変換位相 aki +*/;
    }
    else
    {
        THdcV = THdc + dTHdc*0.5/* 今回設定するdq逆変換位相 aki+ + */;
    }
    while(THdcV > TWOPI)  /* 「0 < θdc < 2π」に制限 */
    {
        THdcV -= TWOPI;
    }
    /* while(THdc < 0.0)  //aki
     {
    THdcV += TWOPI;
     }*/
    while(THdcV < 0.0)
    {
        THdcV += TWOPI;
    }

    /* ************ */
    /* dq逆座標変換 */
    /* ************ */

    s_LPF_vd0 += (Vdc0 - s_LPF_vd0)*k_LPF_vd0;
    s_LPF_vq0 += (Vqc0 - s_LPF_vq0)*k_LPF_vq0;

    SIN0 = sin(THdcV);//aki
    COS0 = cos(THdcV);

    /* dq -> αβ */
    Vac0 = Vdc0*COS0 -Vqc0*SIN0; //-
    Vbc0 = Vdc0*SIN0 + Vqc0*COS0; //+

    /* αβ -> Vuvw */
    Vac0_t = 0.40824892046*Vac0;
    Vbc0_t = 0.70710678118*Vbc0;

    Vuc0 = 2.0*Vac0_t;
    Vvc0 = -Vac0_t + Vbc0_t;
    Vwc0 = -Vac0_t - Vbc0_t;


    switch(PWM_mode)
    {
    case 0: /* SIN PWM（なにもなし） */
        Vuc1 = Vuc0;
        Vvc1 = Vvc0;
        Vwc1 = Vwc0;
        break;
    case 1:
        HIP(); /* HIP変調 */
        break;
    default:
        HIP(); /**/
        break;
    }

    /* PWM Vuvw -> Muvw */
    refu = Vuc1*Power1;//R2Edc0;
    refv = Vvc1*Power1;//;R2Edc0
    refw = Vwc1*Power1;//R2Edc0
    /*  if((vr2_ad>jth)){//||(Rcnt > jthr)){// vr1_ad  0604
      refu = Vuc1*Power1;//vr1_ad
      refv = Vvc1*Power1;
      refw = Vwc1*Power1;
      }
      else{}
      if((vr2_ad<-jth)){//||(Rcnt<-jthr)){ //vr1_ad 0604
      refu = Vuc1*Power1;//-vr1_ad
      refv = Vvc1*Power1;
      refw = Vwc1*Power1;
      }
      else{}*/
    /* if((fabs(s_LPF_N2)>kaitensu)&&(Rot==0)&&(jNorm==0)){
     for(count=1;count<=100; count=count+1){
     refu = 0.65;
     refv = 0.65;
     refw = 0.55;
     }
     }
     else{}*/
    /* --------- */
    /* PWMの設定 */
    /* --------- */
    inverter_set_uvw( refu, refv, refw, YT_cnt,0);  //( refu, refv, refw, YT_cnt, MN )

    /* ----------- */
    /* ICS support */
    /* ----------- */
#ifdef	TEST_M1
    if(YT_cnt == 0)
    {
        cnt++;
        if (cnt>=3)
        {
            ics_watchpoint();
            cnt = 0;
        }
        else {}
    }
    else {}
#endif

//LED1_set(0);
}

//*****************************************************************************
//*****************************************************************************
// MOTOR-2 割込み処理 int_carrier subroutine
//	int_carrier_m2()
//*****************************************************************************
//@****************************************************************************
void	int_carrier_m2(void)
{
    ICU.IR[0x5C].BIT.IR = 0;//0x69
    /* HoleIC PLL */
    //TC_cnt_Ts_2 = MTU2.TCNT;		// MTU2のカウンタ値 	// @***** S
    TC_cnt_Ts_2 = countc2;


//    LED1_set(1);		//	// @*****
    /* ------------------ */
    /* AD変換器　スタート */
    /* ------------------ */
    // 12bit ADC
    S12AD0.ADCSR.BIT.ADST = 1;		// @***** S
    S12AD1.ADCSR.BIT.ADST = 1;		// @***** S
    // 10bit ADC
    AD0.ADCSR.BIT.ADST = 1;		// Joy Stick AN0,AN1,AN2	@***** S

    /* ------------ */
    /* DRV_sts 設定 */
    /* ------------ */
    //SW_2 = SW_in_m2();/* SW1の入力 */
    SW_2 = SW_in();/* SW1の入力 */
    if (SW_2==1)/* Gate OFF DRV_sts=0 */
    {
        DRV_sts_2 = 0;
        s_LPF_N_2 = 0.0;
        s_LPF_N2_2 = 0.0;
        s_kiASR_2 = I_ref_q_ini_2;
        I_ref_ASR_2 = I_ref_q_ini_2;

        S6_MODE_2 = 1; //1
        THdcPLL_2 = THdc_2;
        s_kiPLL_2 = 0.0;
        s_kiACR_d_2 = 0.0;
        s_kiACR_q_2 = 0.0;

        Nrpm_ref_2 = 0.0;
    }
    else
    {
        DRV_sts_2 = 3;
    }
    /* -------------- */
    /* ゲート信号設定 */
    /* -------------- */
    /* -------------------- */
    /* 電流，電圧検出値処理 */
    /* -------------------- */
    /* ↓AD変換待ち */
    while (S12AD0.ADCSR.BIT.ADST==1) {
        nop();    // @*****
    }
#if 0
    while (AD0.ADCSR.BIT.ADST==1) {
        nop();    //0712
    }
    /* 過去の電圧検出値の保存 */
    // an003_2 =  an003_2;/* Vu過去値 */

    /* 電圧，電流値の取り込み */
    anX2 = AD0.ADDRA;// JoyStick X2
    anC02 =AD0.ADDRB;// JoyStick C02
    anY2 = AD0.ADDRC;// JoyStick Y2			// Vu

    an103_2 = S12AD1.ADDR3;			// VR1 Y@@ 180528
    an003_2 = S12AD0.ADDR3;
#endif                                       // VR1 X@@ 180528
    /* 電流は谷割込みのみ有効 */
    if(YT_cnt_2 == 1)  /* Y150614 */
    {
        an000_2 = S12AD1.ADDR0A;		// Iu	// @***** S
        an001_2 = S12AD1.ADDR2;			// Iw	// @***** S
        an102_2 = S12AD1.ADDR1;			// Iv	// @***** S
    }
    else  /* 山割込みの値は不使用 */
    {
        anTMP = S12AD1.ADDR0A;			// Iu	// @***** S
        anTMP = S12AD1.ADDR2;			// Iw	// @***** S
        anTMP = S12AD1.ADDR1;			// Iv	// @***** S
    }

    /* 相電流 */
    iu_ad_2  = -((float)(an000_2 - 2048))/(57.344f*4) - offset_u_2;/*  */
    iv_ad_2  = -((float)(an102_2 - 2048))/(57.344f*4) - offset_v_2;/*  */
    iw_ad_2  = -((float)(an001_2 - 2048))/(57.344f*4) - offset_w_2;/*  */

#if 0
    vr2_adi_2=-((an103_2-fyi_2)/ydiv);
    Rotatei_2 =((an003_2-fxi_2)/xdiv);
#else
    vr2_ad_2=vr2_ad;
    Rotate_2 =Rotate;
#endif
   // vr2_ad_2 += (vr2_adi_2- vr2_ad_2 )*LPF_ad_2;
  //  Rotate_2 += (Rotatei_2-Rotate_2)*LPF_ad_2;

    /************Initialize*******************/


    if((vr2_ad_2<(jth-0.0))&&(vr2_ad_2>-(jth-0.0))) { //vr1_ad 0604 0.02
        if((Rotate_2<(jthr-0.0))&&(Rotate_2>-(jthr-0.0))) {   // 追加　0609 0.02

            pth=0;
            //jth=0.05;



            PORTE.DR.BIT.B5=0;
            work_init_m2();

         /*   kpACR_2 =0;// 0.0665;
            kiACR_2 =0;// 0.00165;
            kpASR_2 =0;//0.084;//Speed
            kiASR_2= 0;//=0.0015;
            Power2=0;*/

        }
        else {
            PORTE.DR.BIT.B5=1;
            Nref1=cNref1;
        }
    }
    else {
        PORTE.DR.BIT.B5=1;   //Inverter EN
        Nref1=cNref1;
    }
    /*******************************************************************/
//    initm2=1;
    /* ボリュームの電圧 */
    //vr2_ad_2 = -((an103 - 2000.0)/4096.0)*power2;	// @@ 17400602

    //if(fabs(s_LPF_N_2)>2) {
        kpACR_2 = 0.002;	//0.0002
        kiACR_2 = 0.0000006;       //0.0005
        kpASR_2 = 0.08;//Speed0.0005
        kiASR_2 = 0.002;//00001
        LPF_ad_2=0.025;//0.025
        Power2=0.083333;//PowerP;
        kpPLL_2 = 40.0;
        kiPLL_2 =0.02;
   /* }
    else {
        kpACR_2=0.55;//kpACR_2+0.001;
        kiACR_2=0.0001;//kiACR_2+0.0002;
        kpASR_2 =0.0008;//kpASR_2+0.00001;//Speed
        kiASR_2 =0.000005;// kiASR_2+0.000002;
        LPF_ad_2=0.025;//0.001
        Power2=0.015;//Power2+0.00021;
    }*/

    /**********************************************************************/

    vr1_ad_2=vr2_ad_2;
    /*    if((vr2_ad_2<(jth+pth))&&(vr2_ad_2>-(jth+pth))){//&&(Rot_2==1)){
    	   if((Rotate_2>jthr)){//||(Rotate_2<-jthr)){
    		   jNorm_2=0;
    		   Rot_2=1;
    		  // pth=0.2;
    	   }
    	   else{jNorm_2=1;}

         }
         else{jNorm_2=1;}

           if((vr2_ad_2<(jth+pth))&&(vr2_ad_2>-(jth+pth))){//&&(Rot_2==1)){
    	   if((Rotate_2<-jthr)){
    		   jNorm_2=0;
    		   Rot_2=1;
    		  // pth=0.2;
    	   }
    	   else{jNorm_2=1;}

         }
         else{jNorm_2=1;}


         if((Rotate_2>jthr)&&(Rot_2==1)){
    	     vr2_ad_2 = -Rotate_2;
    	     vr1_ad_2=  vr2_ad_2/Rotp;

         }
         else{}

         if((Rotate_2<-jthr)&&(Rot_2==1)){
    	     vr2_ad_2 = -Rotate_2;
    	     vr1_ad_2=  vr2_ad_2/Rotp;

         }
         else{}*/
    if((Rotate_2<=jthx)&&(Rotate_2>=-jthx)) {
        Rp=1.0;
    }
    else {}

    if(Rotate_2>jthx) {
        Rp=0.0;

    }
    else {}

    if(Rotate_2<-jthx) {
        Rp=1.0;
    }
    else {}

    // if(jNorm_2==1){   //migi
    //jNorm_2=1;
    // Rot_2=0;
    //  vr1_ad_2=vr2_ad_2*(0.5 - Rotate_2);
    // vr1_ad_2=vr2_ad_2;
    //vr1_ad_2=(vr2_ad_2-Rotate_2)*Rp;//vr2_ad_2 - Rotate_2;
    //  }
    // else{}


    /* if((vr2_ad_2>jth)&&(jNorm_2==1)){ // 2nd wheel Forwaord migi

        Rot_2=0;
       //jth=0.02;
      // vr1_ad_2=(vr2_ad_2/1.0)+(Rotate_2)/2.0;

         vr1_ad_2=vr2_ad_2/dp2;

        if(Rotate_2<-jthx){ //Left Forward

            vr1_ad_2= vr2_ad_2/dp2 -Rotate_2/dpr2;

         }
         else{}

         if(Rotate_2>jthx){//Right Forward

    	 vr1_ad_2=vr2_ad_2/dp2 - Rotate_2/dpr2;

         }
         else{}

      }
      else{}

      if((vr2_ad_2<-jth)&&(jNorm_2==1)){  // 2nd wheel back migi

                vr1_ad_2=(vr2_ad_2)/dp2;
         Rot_2=0;
         //jth=0.03;
        if(Rotate_2<-jthx){ //Left Back

         vr1_ad_2= vr2_ad_2/dp2+(Rotate_2)/dpr2;
         }
         else{}

         if(Rotate_2>jthx){//Right back

    	 vr1_ad_2=vr2_ad_2/dp2+(Rotate_2)/dpr2;

         }
         else{}

      }
      else{}*/


    /* if(vr1_ad_2>=0.35){
    vr1_ad_2=0.35;
    }
    else{}
      if(vr1_ad_2<=-0.35){
     vr1_ad_2=-0.35;
    }
    else{} */

    /* ****************** */
    /* Iuvw -> dq座標変換 */
    /* ****************** */
    /* 電流は谷割込みのみ有効 */
    if(YT_cnt_2 == 1)  /*  */
    {
        /* UVW -> αβ */
        Iac0_2 = 0.816496580928*(iu_ad_2 - 0.5*(iv_ad_2 + iw_ad_2));
        /* ↑Iα=sqrt(2/3)*{Iu-(Iv+Iw)/2} */
        Ibc0_2 = 0.7071067811866*(iv_ad_2 - iw_ad_2);
        /* ↑Iβ=sqrt(1/2)*(Iv-Iw) */

        if((PLL_ON_2 == 1)&&(S6_MODE_2 != 1))
        {
            SIN0_2 = sin(THdcPLL_2);/**/
            COS0_2 = cos(THdcPLL_2);/**/
        }
        else
        {
            SIN0_2 = sin(THdc_2);/**/
            COS0_2 = cos(THdc_2);/**/
        }

        /* αβ -> dq */
        Idc0_2 = Iac0_2*COS0_2 +Ibc0_2*SIN0_2;  //  +
        Iqc0_2 =  -Iac0_2*SIN0_2 + Ibc0_2*COS0_2; //  -
    }
    else {}
    s_LPF_id0_2 += (Idc0_2 - s_LPF_id0_2)*k_LPF_id0_2;
    s_LPF_iq0_2 += (Iqc0_2 - s_LPF_iq0_2)*k_LPF_iq0_2;
    /* *********************************************** */
    /* [ 1 ] 速度検出↓ */
    /* *********************************************** */
    /* MTU1.TGRBにキャプチャ発生 */
    /* MTU1.TGRAにキャプチャ発生 */
#if  1
    if(MTU1.TSR.BIT.TGFA == 1)                   //0606 D
    {
        MTU1.TSR.BIT.TGFA = 0;			// @@ 180528 0606D
        TC_FLG_2 = 1;
        Period_Motor2();
    }
#else
    if(MTU1.TSR.BIT.TGFA == 1)       //0606 B
    {
        TC_cnt_3A_2 = MTU1.TGRA;			// @@ 180528 0606 B
        MTU1.TSR.BIT.TGFA = 0;				// @@ 180528 0606 B
        //TC_cnt_3A_2 = MTU3.TGRA;
        //MTU3.TSR.BIT.TGFB = 0;
        TC_FLG_2 = 1;  /* キャプチャ発生フラグ */
        TC_cnt_Hole_2 = TC_cnt_3A_2;/**/
        t_cnt_2 = TC_cnt_3A_2 - TC_cnt_3A_1_2;
        if(t_cnt_2<1) {
            t_cnt_2=1;
        }
        else {}
        if(t_cnt_2>=cNrpm_P/kdiv) {
            t_cnt_2=cNrpm_P;
        }
        else {}

        // Nrpm = (cNrpm_P/2/t_cnt*2)
        // cNrpm_P = 60 * cIMCLK_FRQ * 1000 / cTr2 * 1000 / cPole); cPole=8;cTr2=64;
        Nrpm_2 = (float)(cNrpm_P / t_cnt_2);		// cNrpm_P=60/cPole*96000000/cTr2; @@ 180528
        //Nrpm_2 = (float)(9000000 / t_cnt_2);		// P=10	60/10*96000000/64 @*****
        //Nrpm_2 = (float)(11250000 / t_cnt_2);		// P=8	60/8*96000000/64 @*****
        kaiten_2=(float)(cNrpm_P / t_cnt_2);

        if( ((Nrpm_2-Nrpm_1_2)<EMR_DRPM) && ((Nrpm_2-Nrpm_1_2)>(-EMR_DRPM)) )
        {   /* 速度異常 */
            Nrpm_1_2 = Nrpm_2;
        }
        else
        {
            Nrpm_2 = Nrpm_1_2;
        }
        TC_cnt_3A_1_2 = TC_cnt_3A_2;
    }
    else {}
#endif
    
#if  1
    if(MTU1.TSR.BIT.TGFB == 1)                   //0606 D
    {
        MTU1.TSR.BIT.TGFB = 0;			// @@ 180528 0606D
        TC_FLG_2 = 1;
        Period_Motor2();
    }
    /* MTU2.TGRAにキャプチャ発生 */
    /* MTU1.TGRBにキャプチャ発生 */
#else
    if(MTU1.TSR.BIT.TGFB == 1)
    {
        TC_cnt_3C_2 = MTU1.TGRB;  //0606 MTU2.TGRA
        MTU1.TSR.BIT.TGFB = 0;    // 0606 MTU2.TSR.BIT.TGFA = 0;

        TC_FLG_2 = 1;  /* キャプチャ発生フラグ */
        TC_cnt_Hole_2 = TC_cnt_3C_2;/**/

        t_cnt_2 = TC_cnt_3C_2 - TC_cnt_3C_1_2;
        if(t_cnt_2<1) {
            t_cnt_2=1;
        }
        else {}
        if(t_cnt_2>=cNrpm_P/kdiv) {
            t_cnt_2=cNrpm_P;
        }
        else {}
        // Nrpm = (cNrpm_P/2/t_cnt*2)
        // cNrpm_P = 60 * cIMCLK_FRQ * 1000 / cTr2 * 1000 / cPole); cPole=8;cTr2=64;
        Nrpm_2 = (float)(cNrpm_P / t_cnt_2);		// cNrpm_P=60/cPole*96000000/cTr2; @@ 180528
        //Nrpm_2 = (float)(9000000 / t_cnt_2);		// P=10	60/10*96000000/64 @*****
        //Nrpm_2 = (float)(11250000 / t_cnt_2);		// P=8	60/8*96000000/64 @*****

        if( ((Nrpm_2-Nrpm_1_2)<EMR_DRPM) && ((Nrpm_2-Nrpm_1_2)>(-EMR_DRPM)) )
        {   /* 速度異常 */
            Nrpm_1_2 = Nrpm_2;
        }
        else
        {
            Nrpm_2 = Nrpm_1_2;
        }
        TC_cnt_3C_1_2 = TC_cnt_3C_2;
    }
    else {}
#endif

#if  1
    if(MTU2.TSR.BIT.TGFA == 1)                   //0606 D
    {
        MTU2.TSR.BIT.TGFA = 0;			// @@ 180528 0606D
        TC_FLG_2 = 1;
        Period_Motor2();
    }
#else

    /* MTU1.TGRAにキャプチャ発生 */
    /* MTU2.TGRAにキャプチャ発生 */
    if(MTU2.TSR.BIT.TGFA == 1)    //0606 MTU1
    {
        TC_cnt_1A_2 = MTU2.TGRA;//0606 MTU1
        MTU2.TSR.BIT.TGFA = 0;//0606 MTU1
        TC_FLG_2 = 1;  /* キャプチャ発生フラグ */
        TC_cnt_Hole_2 = TC_cnt_1A_2;/**/

        t_cnt_2 = TC_cnt_1A_2 - TC_cnt_1A_1_2;
        //t_cnt_2 = TC_cnt_1A_1_2 - TC_cnt_1A_2;
        if(t_cnt_2<1) {
            t_cnt_2=1;
        }
        else {}
        if(t_cnt_2>=cNrpm_P/kdiv) {
            t_cnt_2=cNrpm_P;
        }
        else {}
        // Nrpm = (cNrpm_P/2/t_cnt*2)
        // cNrpm_P = 60 * cIMCLK_FRQ * 1000 / cTr2 * 1000 / cPole); cPole=8;cTr2=64;
        Nrpm_2 = (float)(cNrpm_P / t_cnt_2);		// cNrpm_P=60/cPole*96000000/cTr2; @@ 180528
        //Nrpm_2 = (float)(9000000 / t_cnt_2);		// P=10	60/10*96000000/64 @*****
        //Nrpm_2 = (float)(11250000 / t_cnt_2);		// P=8	60/8*96000000/64 @*****

        if( ((Nrpm_2-Nrpm_1_2)<EMR_DRPM) && ((Nrpm_2-Nrpm_1_2)>(-EMR_DRPM)) )
        {   /* 速度異常 */
            Nrpm_1_2 = Nrpm_2;
        }
        else
        {
            Nrpm_2 = Nrpm_1_2;
        }
        TC_cnt_1A_1_2 = TC_cnt_1A_2;
    }
    else {}
#endif

    /* 正転，逆転のチェック */
    if(R_DR_2==1)/* 正転 */
    {
        Nrpm_s_2 = Nrpm_2;
    }
    else/* 逆転 */
    {
        Nrpm_s_2 = -Nrpm_2;  //aki -Nrpm
    }
    /* 速度フィルタ */
    s_LPF_N_2 += (Nrpm_s_2 - s_LPF_N_2 )*k_LPF_N_2;
    s_LPF_N2_2 += (Nrpm_s_2 - s_LPF_N2_2 )*k_LPF_N2_2;
    kaiten_2 +=(Nrpm_s - s_LPF_N )*k_LPF_N;

    // f[Hz]= Nrpm*cF_P; 計算定数 cF_P=cPole/60/2; cPole=8;
    Fe1_2 = s_LPF_N_2*cF_P;		// cF_P = 8/60/2=0.06666667;// @*****
    //Fe1_2 = s_LPF_N2_2*0.08333333333;	// f[Hz]= Nrpm/60/2*10[pole]	// @*****
    //Fe1_2 = s_LPF_N2_2*0.06666666667;	// f[Hz]= Nrpm/60/2*8[pole]	// @*****

    We1_2 = TWOPI*Fe1_2;  /* ω1 = 2π・f1 */
    dTHdc_2 = Ts0*We1_2;  /* θs = ω1・Ts */
    /* Hole IC PLL  */
    if(	TC_FLG_2 == 1)  /* キャプチャ発生時の速度領域 */
    {
        if(s_LPF_N_2 > NRPM_MIN)  /* 正転 */
        {
            S6_MODE_2_p = 2;/* 0: -sin, 1:6step, 2:+sin */
            S5_MODE_2=S6_MODE_2_p;
        }
        else
        {
            if(s_LPF_N_2 < (-NRPM_MIN))  /* 逆転 */
            {
                S6_MODE_2_p = 0;/* 0: -sin, 1:6step, 2:+sin  aki 0 */
                S5_MODE_2=S6_MODE_2_p;
            }
            else  /* 零付近ウロウロ */
            {
                S6_MODE_2 = 1;/* 0: -sin, 1:6step, 2:+sin */
                
            }
        }
        //if(vr1_ad_2>0.05){  // vr1_ad_2>0.05 0602
        // サンプル開始までのずれ角計算定数 cdt_P=cTr2/cIMCLK_FRQ/1000000; cTr2=64; IMCLK_FRQ=96[MHz]
        // cdt_P = cTr2 / cIMCLK_FRQ / 1000000.= 64/96000000[Hz]=0.00000007
        dTH_hole_2 = cdt_P*((float)( TC_cnt_Ts_2 - TC_cnt_Hole_2))*We1_2;	// @*****
        //dTH_hole_2 = 0.0000666666667*((float)( TC_cnt_Ts_2 - TC_cnt_Hole_2))*We1_2;	// @*****
        // ↑サンプル開始までのずれ角 dt=1/1500000  (1500000=96MHz/64)
        // dTH_hole_2 = 0.0000026666667*((float)( TC_cnt_Ts_2 - TC_cnt_Hole_2))*We1_2;	// @*****
        // ↑サンプル開始までのずれ角 dt=1/375000  (375000=96MHz/256)
        //}
        //else
        //{
        // サンプル開始までのずれ角計算定数 cdt_P=cTr2/cIMCLK_FRQ/1000000; cTr2=64; IMCLK_FRQ=96[MHz]
        // cdt_P = cTr2 / cIMCLK_FRQ / 1000000.= 64/96000000[Hz]=0.00000007
        //  dTH_hole_2 = cdt_P*((float)( TC_cnt_Ts_2 - TC_cnt_Hole_2))*We1_2;	// @*****
        // ↑サンプル開始までのずれ角
        //dTH_hole_2 = 0.0000666666667*((float)( TC_cnt_Ts_2 - TC_cnt_Hole_2))*We1_2;	// @*****
        // ↑サンプル開始までのずれ角 dt=1/1500000  (1500000=96MHz/64)
        //dTH_hole_2 = 0.0000026666667*((float)( TC_cnt_Ts_2 - TC_cnt_Hole_2))*We1_2;	// @*****
        // ↑サンプル開始までのずれ角 dt=1/375000  (375000=96MHz/256)
        //}

        if((dTH_hole_2 > DEG030N)||(dTH_hole_2 < (-DEG030N)))
        {
            dTH_hole_2 = 0.0;
        }
        else {}
    }
    else
    {
        dTH_hole_2 = 0.0;
    }

    /*  a_LPF_N_2=fabs(s_LPF_N_2);

    if(a_LPF_N_2<40){
    		kpPLL_2 = 40.0;	  //12.0
                	kiPLL_2 =0.035;  //0.0035

    }
    else{}
    if((a_LPF_N_2>=40)&&(a_LPF_N_2<60)){
    		kpPLL_2 = 50.0;
                	kiPLL_2 =0.065;

    }
    else{}
    if((a_LPF_N_2>=60)&&(a_LPF_N_2<90)){
    		kpPLL_2 = 60.0;
                	kiPLL_2=0.070;

    }
    else{}
    if((a_LPF_N_2>=90)){
    		kpPLL_2 = 70.0;
                	kiPLL_2 =0.0075;

    }
    else{}*/

    HUVW_2 = UVW_in_m2(); /* Hole IC信号の状態 */
    switch (HUVW_2)
    {
    case 1:
        V_MODE_2 = 2;
        break;
    case 2:
        V_MODE_2 = 4;
        break;
    case 3:
        V_MODE_2 = 3;
        break;
    case 4:
        V_MODE_2 = 6;
        break;
    case 5:
        V_MODE_2 = 1;
        break;
    case 6:
        V_MODE_2 = 5;
        break;
    default:
        V_MODE_2 = 1;
        break;
    }
    if((S6_MODE_2 == 2)&&(TC_FLG_2 == 1))
    {
        switch (V_MODE_2)
        {
        case 1:
            TH_hole_2 = DEG210N;  /* θhole[rad] 210 */
            break;
        case 2:
            TH_hole_2 = DEG270N;  /* θhole[rad] 270 */
            break;
        case 3:
            TH_hole_2 = DEG330N;  /* θhole[rad] 330 */
            break;
        case 4:
            TH_hole_2 = DEG030N;  /* θhole[rad] 30 */
            break;
        case 5:
            TH_hole_2 = DEG090N;  /* θhole[rad] 90 */
            break;
        case 6:
            TH_hole_2 = DEG150N;  /* θhole[rad] 150 */
            break;
        default:
            TH_hole_2 = DEG210N;  /* θhole[rad] 210 */
            break;
        }
        THdc_2 = TH_hole_2 + dTH_hole_2;
        TH_sin_on_2 = 1;

        THdc_err_2 = THdc_2 - THdcPLL_2;
        while(THdc_err_2 > ONEPI)  /* 「-π < θdc < π」に制限 */
        {
            THdc_err_2 -= TWOPI;
        }
        while(THdc_err_2 < (-ONEPI))  /* 「-π < θdc < π」に制限 */
        {
            THdc_err_2 += TWOPI;
        }/**/
    }
    else {}
    if((S6_MODE_2 == 0)&&(TC_FLG_2 == 1))
    {
        switch (V_MODE_2)
        {
        case 1:
            TH_hole_2 = DEG270N;  /* θhole[rad] 270 */
            break;
        case 2:
            TH_hole_2 = DEG330N;  /* θhole[rad] 330 */
            break;
        case 3:
            TH_hole_2 = DEG030N;  /* θhole[rad] 30 */
            break;
        case 4:
            TH_hole_2 = DEG090N;  /* θhole[rad] 90 */
            break;
        case 5:
            TH_hole_2 = DEG150N;  /* θhole[rad] 150 */
            break;
        case 6:
            TH_hole_2 = DEG210N;  /* θhole[rad] 210 */
            break;
        default:
            TH_hole_2 = DEG270N;  /* θhole[rad] 270 */
            break;

        }
        THdc_2 = TH_hole_2 + dTH_hole_2;//aki +
        TH_sin_on_2 = 1;

        THdc_err_2 = THdc_2 - THdcPLL_2; //aki -
        while(THdc_err_2 >( ONEPI))  /* 「-π < θdc < π」に制限 */
        {
            THdc_err_2 -= TWOPI;  //aki -
        }
        while(THdc_err_2 < (-ONEPI))  /* 「-π < θdc < π」に制限 */
        {
            THdc_err_2 += TWOPI;  //aki+
        }/**/
    }
    else {}

 if(S6_MODE_2 == 1)
    {

     //   if(vr2_ad_2>=jth) {
            switch (V_MODE_2)
            {
            case 1:
                TH_hole_2 = DEG240N;  //240
                break;
            case 2:
                TH_hole_2 = DEG300N;  //300
                break;
            case 3:
                TH_hole_2 = 0.0;//DEG060N;     //0.0
                break;
            case 4:
                TH_hole_2 = DEG060N;  //60
                S6_MODE_2=S5_MODE_2;
                break;
            case 5:
                TH_hole_2 = DEG120N;  //120
                break;
            case 6:
                TH_hole_2 = DEG180N;  //180
                break;
            default:
                TH_hole_2 =DEG240N;  //240
                break;
            }
      /*  }
        else {}

        if(vr2_ad_2<-jth) {
            switch (V_MODE_2)
            {
            case 1:
                TH_hole_2 = DEG240N;  //249
                break;
            case 2:
                TH_hole_2 = DEG300N;  //300
                break;
            case 3:
                TH_hole_2 = 0.0;     //0.0
                break;
            case 4:
                TH_hole_2 = DEG060N;  //60
                break;
            case 5:
                TH_hole_2 = DEG120N;  //120
                break;
            case 6:
                TH_hole_2 = DEG180N;  //180
                break;
            default:
                TH_hole_2 =DEG240N;  //240
                break;
            }
        }
        else {}*/
        THdc_2 = TH_hole_2;//aki +
        TH_sin_on_2 = 0;

        THdcPLL_2 = THdc_2;/*aki+*/
        THdc_err_2 = 0.0;/**/
        s_kiPLL_2 = 0.0;/**/
        //Start=St6;       //0601
    }
    else {/*Start=StV;*/}    //0601

    TC_FLG_2 = 0;
    if(TH_sin_on_2 == 1)
    {
        THdc_2 = THdc_2 + dTHdc_2;/* 次回のdq変換位相 */
    }
    else {}
    while(THdc_2 > TWOPI)  /* 「0 < θdc < 2π」に制限 */
    {
        THdc_2 -= TWOPI;
    }
    while(THdc_2 < 0.0)
    {
        THdc_2 += TWOPI;
    }
    /************/
    /*  PLL制御 */
    /* ******** */
    s_kiPLL_2 += kiPLL_2*THdc_err_2;  //0603
    W1PLL_2 = s_kiPLL_2 + kpPLL_2*THdc_err_2;  //0603
    THdcPLL_2 = THdcPLL_2 +  W1PLL_2*Ts0;
    while(THdcPLL_2 > TWOPI)  /* 「0 < θdc < 2π」に制限 */
    {
        THdcPLL_2 -= TWOPI;
    }
    while(THdcPLL_2 < 0.0) //aki
    {
        THdcPLL_2 += TWOPI;
    }
    /* モードから位相がはみ出さないように処理 */
    switch(V_MODE_2)
    {
    case 1:
        if((DEG330N > THdc_2 )&&( THdc_2 > DEG270N )) {
            THdc_2 = DEG270N;
        }
        else
        {
            if(( DEG150N < THdc_2 )&&( THdc_2 < DEG210N )) {
                THdc_2 = DEG210N;
            }
            else {}
        }
        break;
    case 2:
        if(THdc_2 > DEG330N ) {
            THdc_2 = DEG330N;
        }
        else
        {
            if((DEG210N < THdc_2 )&&( THdc_2 < DEG270N )) {
                THdc_2 = DEG270N;
            }
            else {}
        }
        break;
    case 3:
        if(( DEG090N > THdc_2 )&&( THdc_2  > DEG030N )) {
            THdc_2 = DEG030N;
        }
        else
        {
            if((DEG270N < THdc_2 )&&( THdc_2 < DEG330N )) {
                THdc_2 = DEG330N;
            }
            else {}
        }
        break;
    case 4:
        if((DEG150N > THdc_2 )&&( THdc_2 > DEG090N )) {
            THdc_2 = DEG090N;
        }
        else
        {
            if(( 0 < THdc_2 )&&( THdc_2 < DEG030N )) {
                THdc_2 = DEG030N;
            }
            else {}
        }
        break;
    case 5:
        if((DEG210N > THdc_2 )&&( THdc_2 > DEG150N )) {
            THdc_2 = DEG150N;
        }
        else
        {
            if(( DEG030N < THdc_2 )&&( THdc_2 < DEG090N )) {
                THdc_2 = DEG090N;
            }
            else {}
        }
        break;
    case 6:
        if((DEG270N > THdc_2 )&&( THdc_2 > DEG210N )) {
            THdc_2 = DEG210N;
        }
        else
        {
            if((DEG090N < THdc_2 )&&( THdc_2 < DEG150N )) {
                THdc_2 = DEG150N;
            }
            else {}
        }
        break;
    default:
        break;
    }
    /* ↑ここまで（速度・位相計算） */
    switch(DRV_sts_2)
    {
    case 0:
        s_LPF_N_2 = 0.0;
        s_LPF_N2_2 = 0.0;
        break;
    case 1:
        s_LPF_N_2 = 0.0;
        s_LPF_N2_2 = 0.0;
        break;
    case 2:
        break;
    case 3:
        break;
    default:
        s_LPF_N_2 = 0.0;
        s_LPF_N2_2 = 0.0;
        break;
    }
    if (DRV_sts_2 == 0)
    {
        Nrpm_2 = 0.0;
        Nrpm_1_2 = 0.0;
    }
    else {}
    /* *********************************************** */
    /* [ 2 ] 速度制御 ↓ */
    /* *********************************************** */
    /* 回転数指令，誤差信号の処理 */
    switch(DRV_sts_2)
    {
    case 0:
        Nrpm_ref_2 = 0.0;
        Nerr_2 = 0.0;
        break;
    case 3:
        Nrpm_ref0_2 =fabs( Nref1*vr1_ad_2); //aki vr1_ad_2 0602

        //if(Nrpm_ref0_2>0) {
            // Nrpm_ref0_2 = Nref1*(vr1_ad_2-0.05);
            if(Nref0_2 > Nrpm_ref0_2)
            {
                Nref0_2 -= dN_HI_N; //aki -
                if(Nref0_2 < Nrpm_ref0_2)
                {
                    Nref0_2 = Nrpm_ref0_2;
                }
                else {}
            }
            else {}

            if(Nref0_2 < Nrpm_ref0_2)
            {
                Nref0_2 += dN_HI_P;  //aki +
                if(Nref0_2 > Nrpm_ref0_2)
                {
                    Nref0_2 = Nrpm_ref0_2;
                }
                else {}
            }
            else {}
            if(Nref0_2<N_LOW_MAX)
            {
                Nref0_2 = N_LOW_MAX;
            }
            else {}
            Nrpm_ref_2 = Nref0_2;

           if(R_DR==1){
            Nerr_2 = Nrpm_ref_2 - Nrpm_s_2;
            }
            else{
             Nerr_2 = Nrpm_ref_2 + Nrpm_s_2;
              }
        if(Nerr_2>=50) {
            Nerr_2=50;
        }
        else {}
        if(Nerr_2<-50) {
            Nerr_2=-50;
        }
        else {}
        /*}
        else {}
        if(Nrpm_ref0_2<0) {
            //Nrpm_ref0_2 = Nref1*(vr1_ad_2+0.05);
            if(Nref0_2 < Nrpm_ref0_2)//minus
            {
                Nref0_2 +=dN_HI_N; //aki +
                if(Nref0_2 > Nrpm_ref0_2)
                {
                    Nref0_2 = Nrpm_ref0_2;
                }
                else {}
            }
            else {}

            if(Nref0_2 > Nrpm_ref0_2)//minus
            {
                Nref0_2 -= dN_HI_P;  //aki +
                if(Nref0_2 < Nrpm_ref0_2)
                {
                    Nref0_2 = Nrpm_ref0_2;
                }
                else {}
            }
            else {}
            if(Nref0_2>-N_LOW_MAX)
            {
                Nref0_2 =-N_LOW_MAX;//aki
            }
            else {}
            Nrpm_ref_2 = Nref0_2;
            Nerr_2 =- Nrpm_ref_2 + Nrpm_s_2;//センサ付 aki -
        }
        else {}*/
        break;
    default:
        break;
    }
    /* ----------- */
    /* ASRのPI制御 */
    /* ----------- */
    s_kiASR_2 += kiASR_2*Nerr_2;
    if(s_kiASR_2 > I1_LIM)
    {
        s_kiASR_2 = I1_LIM;
    }
    else
    {
        if(s_kiASR_2 < (-I1_LIM))
        {
            s_kiASR_2 = -I1_LIM;
        } else {}
    }
    I_ref_ASR_2 = s_kiASR_2 + kpASR_2*Nerr_2;
    if(I_ref_ASR_2 > I1_LIM)
    {
        I_ref_ASR_2 = I1_LIM;
    }
    else
    {
        if(I_ref_ASR_2 < (-I1_LIM))
        {
            I_ref_ASR_2 = -I1_LIM;
        } else {}
    }
    /* ASRの初期値 */
    if(DRV_sts_2 != 3)
    {
        s_kiASR_2 = I_ref_q_ini_2;
        I_ref_ASR_2 = I_ref_q_ini_2;
    }
    else {}
    /* *********************************************** */
    /* [ 3 ] 電流制御 ↓ */
    /* *********************************************** */
    /* 電流指令 */
    switch(DRV_sts_2)
    {
    case 0: /* 待機状態 */
        I_ref_q_2 = 0; 			/* q軸電流指令 */
        I_err_q_2 = 0;			/* q軸電流偏差 */
        s_kiACR_q_2 = 0.0;		/* q軸ACRの積分器クリア */
        s_kiASR_2 = 0.0;		/* ASRの積分器クリア */
        break;
    case 3: /* 駆動開始 */
        I_ref_d_2 = 0.0;		/* d軸電流指令 */
        I_err_d_2 = I_ref_d_2 - Idc0_2;	/* d軸電流偏差 */
        I_ref_q_2 = I_ref_ASR_2;	/* q軸電流指令 */
        I_err_q_2 = I_ref_q_2 - Iqc0_2;	/* q軸電流偏差 */
        break;
    default:
        I_ref_q_2 = 0;
        I_err_q_2 = 0;
        s_kiACR_q_2 = 0.0;
        s_kiASR_2 = 0.0;
        break;
    }
    /* ----------- */
    /* ACRのPI制御 */
    /* ----------- */
    /* d軸ACR */
    s_kiACR_d_2 += kiACR_2*I_err_d_2; /* d軸積分処理 */
    if(s_kiACR_d_2 > V1_LIM)
    {
        s_kiACR_d_2 = V1_LIM;
    }
    else
    {
        if(s_kiACR_d_2 < (-V1_LIM))
        {
            s_kiACR_d_2 = -V1_LIM;
        } else {}
    }
    Vdc0_2 = s_kiACR_d_2 + kpACR_2*I_err_d_2; /* d軸電圧指令Vd */

    if(Vdc0_2 > V1_LIM)
    {
        Vdc0_2 = V1_LIM;
    }
    else
    {
        if(Vdc0_2 < (-V1_LIM))
        {
            Vdc0_2 = -V1_LIM;
        } else {}
    }
    /* q軸ACR */
    s_kiACR_q_2 += kiACR_2*I_err_q_2;  /* q軸積分処理 */
    if(s_kiACR_q_2 > V1_LIM)
    {
        s_kiACR_q_2 = V1_LIM;
    }
    else
    {
        if(s_kiACR_q_2 < (-V1_LIM))
        {
            s_kiACR_q_2 = -V1_LIM;
        } else {}
    }
    Vqc0_2 = s_kiACR_q_2 + kpACR_2*I_err_q_2; /* q軸電圧指令Vq */

    if(Vqc0_2 > V1_LIM)
    {
        Vqc0_2 = V1_LIM;
    }
    else
    {
        if(Vqc0_2 < (-V1_LIM))
        {
            Vqc0_2 = -V1_LIM;
        } else {}
    }
    /* 電流フィルタ */
    s_LPF_i_2 += (Iqc0_2 - s_LPF_i_2 )*k_LPF_i_2;
    /* *********************************************** */
    /* [ 4 ] PWMの設定 */
    /* *********************************************** */
    /* mのリミッタ */
    if      (m_2 >  m1_LIM) {
        m_2 =  m1_LIM;
    }
    else if (m_2 < (-m1_LIM)) {
        m_2 = -m1_LIM;
    }
    else               { /* no code */ }
    if (DRV_sts_2 == 0) {
        m_2 = 0.0;
    }
    else       { /* no code */ }
    /* --------- */
    /* LEDの設定 */
    /* --------- */
    /* ホールIC信号 */
//    LED2_set(U_in_m2());	//	// @*****
//    LED3_set(V_in_m2());	//	// @*****
//    LED4_set(W_in_m2());	//	// @*****
    /* 過去モードの保存 */
    VMODE_z2_2 = VMODE_z1_2;/* 前回値保存 */
    //VMODE_z1_2 = VMODE_2;/* 前回値保存 */
    /* ------------ */
    /* モードの更新 */
    /* ------------ */
    UVW_2 = UVW_in_m2(); /* センサ付・ホールIC信号 */
    switch(DRV_sts_2)
    {
    case 0:
        VMODE_2 = 1;
        break;
    case 1:
        VMODE_2 = 1;
        break;
    case 2:

    case 3: /* ホールIC信号→VMODEのデコード　*/
        switch (UVW_2)
        {
        case 1:
            VMODE_z1_2 = 2;
            break;
        case 2:
            VMODE_z1_2 = 4;
            break;
        case 3:
            VMODE_z1_2 = 3;
            break;
        case 4:
            VMODE_z1_2 = 6;
            break;
        case 5:
            VMODE_z1_2 = 1;
            break;
        case 6:
            VMODE_z1_2 = 5;
            break;
        default:
            VMODE_z1_2 = 1;
            break;
        }
        break;
    default:
        break;
    }
    /* ---------------------- */
    /* 回転方向 */
    /* R_DR -> 1:正転，0:逆転 */
    /* ---------------------- */
   /* if(VMODE_z2_2 == VMODE_z1_2) {}
    else
    {
        if(VMODE_z2_2 < VMODE_z1_2)
        {
            if((VMODE_z2_2==1)&&(VMODE_z1_2==6)) {
                R_DR_2=0;   // R_DR_2=0 1
            }
            else {
                R_DR_2=1;
            }
        }
        else
        {
            if((VMODE_z2_2==6)&&(VMODE_z1_2==1)) {
                R_DR_2=1;   //R_DR_2=1 0
            }
            else {
                R_DR_2=0;
            }
        }
    }*/
    /* **************** */
    /*     位相更新     */
    /* **************** */
    We1_2 = TWOPI*Fe1_2;  /* ω1 = 2π・f1 */
    dTHdc_2 = Ts0*We1_2;  /* θs = ω1・Ts aki +*/

    if((PLL_ON_2 == 1)&&(S6_MODE_2 != 1))
    {
        THdcV_2 = THdcPLL_2 + dTHdc_2*0.5/* 今回設定するdq逆変換位相 aki +*/;
    }
    else
    {
        THdcV_2 = THdc_2 + dTHdc_2*0.5/* 今回設定するdq逆変換位相 aki+ + */;
    }
    while(THdcV_2 > TWOPI)  /* 「0 < θdc < 2π」に制限 */
    {
        THdcV_2 -= TWOPI;
    }
    while(THdcV_2 < 0.0)
    {
        THdcV_2 += TWOPI;
    }
    /* ************ */
    /* dq逆座標変換 */
    /* ************ */
    s_LPF_vd0_2 += (Vdc0_2 - s_LPF_vd0_2)*k_LPF_vd0_2;
    s_LPF_vq0_2 += (Vqc0_2 - s_LPF_vq0_2)*k_LPF_vq0_2;
    SIN0_2 = sin(THdcV_2);//aki
    COS0_2 = cos(THdcV_2);
    /* dq -> αβ */
    Vac0_2 = Vdc0_2*COS0_2 -Vqc0_2*SIN0_2; //-
    Vbc0_2 = Vdc0_2*SIN0_2 + Vqc0_2*COS0_2; //+
    /* αβ -> Vuvw */
    Vac0_t_2 = 0.40824892046*Vac0_2;
    Vbc0_t_2 = 0.70710678118*Vbc0_2;
    Vuc0_2 = 2.0*Vac0_t_2;
    Vvc0_2 = -Vac0_t_2 + Vbc0_t_2;
    Vwc0_2 = -Vac0_t_2 - Vbc0_t_2;
    switch(PWM_mode_2)
    {
    case 0: /* SIN PWM（なにもなし） */
        Vuc1_2 = Vuc0_2;
        Vvc1_2 = Vvc0_2;
        Vwc1_2 = Vwc0_2;
        break;
    case 1:
        HIP_m2(); /* HIP変調 */
        break;
    default:
        HIP_m2(); /**/
        break;
    }
    /* PWM Vuvw -> Muvw */
    refu_2 = Vuc1_2*Power2;
    refv_2 = Vvc1_2*Power2;
    refw_2 = Vwc1_2*Power2;
    /*  if((vr2_ad_2>jth)){//||(Rcnt_2>jthr)){  //0604
      refu_2 = Vuc1_2*Power2; //vr1_ad_2
      refv_2 = Vvc1_2*Power2;
      refw_2 = Vwc1_2*Power2;
      }
      else{}
      if((vr2_ad_2<=-jth)){//||(Rcnt_2<-jthr)){ //0604
      refu_2 = Vuc1_2*Power2;//-vr1_ad_2
      refv_2 = Vvc1_2*Power2;
      refw_2 = Vwc1_2*Power2;
      }
      else{}*/
    /*if((fabs(s_LPF_N2)>kaitensu)&&(Rot_2==0)&&(jNorm_2==0)){
     for(count=1;count<=100; count=count+1){
     refu_2 = 0.65;
     refv_2 = 0.65;
     refw_2 = 0.65;
     }
     }
     else{}*/
    /* --------- */
    /* PWMの設定 */
    /* --------- */
    inverter_set_uvw_2( refu_2, refv_2, refw_2, YT_cnt_2,1);  //( refu_2, refv_2, refw_2, YT_cnt_2,MN )
#ifndef	TEST_M1
    /* ----------- */
    /* ICS support */
    /* ----------- */
    if(YT_cnt_2 == 0)
    {
        cnt_2++;
        if (cnt_2>=3)
        {
            ics_watchpoint();
            cnt_2 = 0;
        }
        else {}
    }
    else {}
#endif

//    LED1_set(0);		// @*****
}

//*****************************************************************************
//@****************************************************************************

void	Mtu4IntFunc_V(void)	// M-1 MPU4 山谷割込み
{
    //MTU4.TSR.BIT.TGFA=0;
    if((MTU3.TSR.BIT.TCFV==0)&&(MTU4.TSR.BIT.TCFV==1)) { //谷
        //  if((MTU4.TSR.BIT.TCFV==1)){//谷
        YT_cnt = MTU4.TSR.BIT.TCFV; //0
        MTU4.TSR.BIT.TCFV=0;
        PORTB.DR.BIT.B5=1;
    }
    else {
        YT_cnt = 0;   //山//1
    }
    if(MTU3.TSR.BIT.TCFV==1) {
        ov3=MTU3.TSR.BIT.TCFV;
        MTU3.TSR.BIT.TCFV=0;
    }
    YT_cnt_2 =0;
    MTU3.TSR.BIT.TCFV=0;
    MTU4.TSR.BIT.TCFV=0;
    MN = 0;
    MTU4.TIER.BIT.TCIEV = 0;
    int_carrier_m1();
    PORTB.DR.BIT.B5=0;
    MTU7.TIER.BIT.TCIEV = 1;
    //MTU4.TIER.BIT.TCIEV = 0;
    countc1++;
    countc2++;

}


void	Mtu7IntFunc_V(void)	// M-2 MPU7 山谷割込み
{
    //MTU7.TSR.BIT.TGFA=0;
    if((MTU6.TSR.BIT.TCFV==0)&&(MTU7.TSR.BIT.TCFV==1)) { //谷
        //if((MTU7.TSR.BIT.TCFV==1)){//谷
        YT_cnt_2 =MTU7.TSR.BIT.TCFV ; //0
        MTU7.TSR.BIT.TCFV=0;
        PORTB.DR.BIT.B7=1;
    }
    else {
        YT_cnt_2 = 0;   //1
    }

    if(MTU6.TSR.BIT.TCFV==1) {
        ov6=MTU6.TSR.BIT.TCFV;
        MTU6.TSR.BIT.TCFV=0;
    }
    YT_cnt=0;
    MTU6.TSR.BIT.TCFV=0;
    MTU7.TSR.BIT.TCFV=0;
    MN = 1;
    MTU7.TIER.BIT.TCIEV = 0;
    //PORTB.DR.BIT.B5=1;
    int_carrier_m2();
    PORTB.DR.BIT.B7=0;
    //MTU7.TIER.BIT.TCIEV = 0;
    MTU4.TIER.BIT.TCIEV = 1;
    countc1++;
    countc2++;
}
